import os from 'node:os';
import fs from 'node:fs/promises';
import path from 'node:path';
import { format } from 'node:util';
import downloadBundle from 'download';
import logger from '@wdio/logger';
import { request } from 'undici';
import { download } from '@vscode/test-electron';
import { SevereServiceError } from 'webdriverio';
import { launcher as ChromedriverServiceLauncher } from 'wdio-chromedriver-service';
import startServer from './server/index.js';
import { validatePlatform, fileExist, directoryExists, isMultiremote, isChrome } from './utils.js';
import { DEFAULT_CHANNEL, VSCODE_RELEASES, VSCODE_MANIFEST_URL, CHROMEDRIVER_RELEASES, CHROMEDRIVER_DOWNLOAD_PATH, DEFAULT_CACHE_PATH, VSCODE_CAPABILITY_KEY, VSCODE_WEB_STANDALONE, DEFAULT_VSCODE_WEB_HOSTNAME } from './constants.js';
const VERSIONS_TXT = 'versions.txt';
const log = logger('wdio-vscode-service/launcher');
export default class VSCodeServiceLauncher extends ChromedriverServiceLauncher {
    constructor(_options, _capabilities, config) {
        super(_options, _capabilities, config);
        this._options = _options;
        this._capabilities = _capabilities;
        this._cachePath = this._options.cachePath || DEFAULT_CACHE_PATH;
        this._mapCapabilities = () => { };
    }
    // @ts-expect-error this service uses provided params
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * check if for given version we already have all bundles
         * and continue without download if possible
         */
        const versionsFilePath = path.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await fileExist(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[VSCODE_CAPABILITY_KEY].version || cap.browserVersion || DEFAULT_CHANNEL;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
            this._mapBrowserCapabilities(this.options);
        }
        return super.onPrepare();
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await startServer(vscodeStandalone, cap[VSCODE_CAPABILITY_KEY]);
            cap[VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        if (versionsFileExist) {
            const content = JSON.parse((await fs.readFile(versionsFilePath)).toString());
            const chromedriverPath = path.join(this._cachePath, `chromedriver-${content[version]?.chromedriver}`);
            const vscodePath = (cap[VSCODE_CAPABILITY_KEY]?.binary
                || path.join(this._cachePath, `vscode-${process.platform}-${process.arch}-${content[version]?.vscode}`));
            if (content[version] && await fileExist(chromedriverPath) && await fileExist(vscodePath)) {
                log.info(`Skipping download, bundles for VSCode v${content[version]?.vscode} `
                    + `and Chromedriver v${content[version]?.chromedriver} already exist`);
                Object.assign(cap, this.options);
                cap[VSCODE_CAPABILITY_KEY].binary = (cap[VSCODE_CAPABILITY_KEY].binary
                    || await this._downloadVSCode(content[version]?.vscode));
                this.chromedriverCustomPath = chromedriverPath;
                return;
            }
        }
        const [vscodeVersion, chromedriverVersion, chromedriverPath] = await this._setupChromedriver(version);
        this.chromedriverCustomPath = chromedriverPath;
        const serviceArgs = {
            chromedriver: { version: chromedriverVersion, path: chromedriverPath },
            vscode: {
                version: vscodeVersion,
                path: cap[VSCODE_CAPABILITY_KEY]?.binary || await this._downloadVSCode(vscodeVersion)
            }
        };
        Object.assign(cap, this.options);
        cap[VSCODE_CAPABILITY_KEY].binary = serviceArgs.vscode.path;
        await this._updateVersionsTxt(version, serviceArgs, versionsFileExist);
    }
    /**
     * Downloads Chromedriver bundle for given VSCode version
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "insiders" if `desiredReleaseChannel` is set to this otherwise a concrete version
     */
    async _setupChromedriver(desiredReleaseChannel) {
        const version = await this._fetchVSCodeVersion(desiredReleaseChannel);
        try {
            const chromedriverVersion = await this._fetchChromedriverVersion(version);
            log.info(`Download Chromedriver (v${chromedriverVersion})`);
            await downloadBundle(format(CHROMEDRIVER_DOWNLOAD_PATH, chromedriverVersion, validatePlatform()), this._cachePath, { extract: true, strip: 1 });
            const ext = os.platform().startsWith('win') ? '.exe' : '';
            const chromedriverPath = path.join(this._cachePath, `chromedriver-${chromedriverVersion}${ext}`);
            await fs.rename(path.join(this._cachePath, `chromedriver${ext}`), chromedriverPath);
            /**
             * return 'insiders' if desired release channel
             */
            return version === 'main'
                ? [desiredReleaseChannel, chromedriverVersion, chromedriverPath]
                : [version, chromedriverVersion, chromedriverPath];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up Chromedriver ${err.message}`);
        }
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await download({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        if (desiredReleaseChannel === 'insiders') {
            return 'main';
        }
        try {
            log.info(`Fetch releases from ${VSCODE_RELEASES}`);
            const { body: versions } = await request(VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const { body } = await request(format(VSCODE_MANIFEST_URL, vscodeVersion), {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            const { body: chromedriverVersion } = await request(format(CHROMEDRIVER_RELEASES, chromium.version.split('.')[0]), {});
            return await chromedriverVersion.text();
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await request(format(VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await directoryExists(folder))) {
                await downloadBundle(info.url, folder, { extract: true, strip: 1 });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, serviceArgs, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: serviceArgs.chromedriver.version,
                vscode: serviceArgs.vscode.version
            }
        };
        const versionsTxtPath = path.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return fs.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await fs.readFile(versionsTxtPath, 'utf-8')).toString());
        return fs.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
    _mapBrowserCapabilities(options) {
        if (isMultiremote(this._capabilities)) {
            throw new SevereServiceError('This service deson\'t support multiremote yet');
        }
        for (const cap of this._capabilities) {
            if (isChrome(cap)) {
                Object.assign(cap, options);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sU0FBUyxDQUFBO0FBQ3hCLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFBO0FBQ2pDLE9BQU8sSUFBSSxNQUFNLFdBQVcsQ0FBQTtBQUM1QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sV0FBVyxDQUFBO0FBRWxDLE9BQU8sY0FBYyxNQUFNLFVBQVUsQ0FBQTtBQUNyQyxPQUFPLE1BQU0sTUFBTSxjQUFjLENBQUE7QUFDakMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUNoQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFDaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sYUFBYSxDQUFBO0FBQ2hELE9BQU8sRUFBRSxRQUFRLElBQUksMkJBQTJCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQTtBQUduRixPQUFPLFdBQVcsTUFBTSxtQkFBbUIsQ0FBQTtBQUMzQyxPQUFPLEVBQ0gsZ0JBQWdCLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQzNELFFBQVEsRUFDWCxNQUFNLFlBQVksQ0FBQTtBQUNuQixPQUFPLEVBQ0gsZUFBZSxFQUFFLGVBQWUsRUFBRSxtQkFBbUIsRUFBRSxxQkFBcUIsRUFDNUUsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUUscUJBQXFCLEVBQ3JFLHFCQUFxQixFQUFFLDJCQUEyQixFQUNyRCxNQUFNLGdCQUFnQixDQUFBO0FBdUJ2QixNQUFNLFlBQVksR0FBRyxjQUFjLENBQUE7QUFDbkMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLDhCQUE4QixDQUFDLENBQUE7QUFDbEQsTUFBTSxDQUFDLE9BQU8sT0FBTyxxQkFBc0IsU0FBUSwyQkFBMkI7SUFJMUUsWUFDWSxRQUF3QixFQUN4QixhQUF3QyxFQUNo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Q0FBQTthQUM5QjtTQUNKO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9zIGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ25vZGU6dXRpbCdcblxuaW1wb3J0IGRvd25sb2FkQnVuZGxlIGZyb20gJ2Rvd25sb2FkJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICdAd2Rpby9sb2dnZXInXG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAndW5kaWNpJ1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICdAdnNjb2RlL3Rlc3QtZWxlY3Ryb24nXG5pbXBvcnQgeyBTZXZlcmVTZXJ2aWNlRXJyb3IgfSBmcm9tICd3ZWJkcml2ZXJpbydcbmltcG9ydCB7IGxhdW5jaGVyIGFzIENocm9tZWRyaXZlclNlcnZpY2VMYXVuY2hlciB9IGZyb20gJ3dkaW8tY2hyb21lZHJpdmVyLXNlcnZpY2UnXG5pbXBvcnQgdHlwZSB7IE9wdGlvbnMsIENhcGFiaWxpdGllcyB9IGZyb20gJ0B3ZGlvL3R5cGVzJ1xuXG5pbXBvcnQgc3RhcnRTZXJ2ZXIgZnJvbSAnLi9zZXJ2ZXIvaW5kZXguanMnXG5pbXBvcnQge1xuICAgIHZhbGlkYXRlUGxhdGZvcm0sIGZpbGVFeGlzdCwgZGlyZWN0b3J5RXhpc3RzLCBpc011bHRpcmVtb3RlLFxuICAgIGlzQ2hyb21lXG59IGZyb20gJy4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIERFRkFVTFRfQ0hBTk5FTCwgVlNDT0RFX1JFTEVBU0VTLCBWU0NPREVfTUFOSUZFU1RfVVJMLCBDSFJPTUVEUklWRVJfUkVMRUFTRVMsXG4gICAgQ0hST01FRFJJVkVSX0RPV05MT0FEX1BBVEgsIERFRkFVTFRfQ0FDSEVfUEFUSCwgVlNDT0RFX0NBUEFCSUxJVFlfS0VZLFxuICAgIFZTQ09ERV9XRUJfU1RBTkRBTE9ORSwgREVGQVVMVF9WU0NPREVfV0VCX0hPU1ROQU1FXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJ1xuaW1wb3J0IHR5cGUge1xuICAgIFNlcnZpY2VPcHRpb25zLCBTZXJ2aWNlQ2FwYWJpbGl0eSwgVlNDb2RlQ2FwYWJpbGl0aWVzLCBXZWJTdGFuZGFsb25lUmVzcG9uc2UsXG4gICAgQnVuZGxlXG59IGZyb20gJy4vdHlwZXMnXG5cbmludGVyZmFjZSBCdW5kZUluZm9ybWF0aW9uIHtcbiAgICBjaHJvbWVkcml2ZXI6IHN0cmluZ1xuICAgIHZzY29kZTogc3RyaW5nXG59XG5pbnRlcmZhY2UgTWFuaWZlc3Qge1xuICAgIHJlZ2lzdHJhdGlvbnM6IFJlZ2lzdHJhdGlvbltdXG59XG5pbnRlcmZhY2UgUmVnaXN0cmF0aW9uIHtcbiAgICB2ZXJzaW9uOiBzdHJpbmdcbiAgICBjb21wb25lbnQ6IHtcbiAgICAgICAgZ2l0OiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgfVxuICAgIH1cbn1cbnR5cGUgVmVyc2lvbnMgPSB7IFtkZXNpcmVkVmVyc2lvbjogc3RyaW5nXTogQnVuZGVJbmZvcm1hdGlvbiB8IHVuZGVmaW5lZCB9XG5cbmNvbnN0IFZFUlNJT05TX1RYVCA9ICd2ZXJzaW9ucy50eHQnXG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dkaW8tdnNjb2RlLXNlcnZpY2UvbGF1bmNoZXInKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVlNDb2RlU2VydmljZUxhdW5jaGVyIGV4dGVuZHMgQ2hyb21lZHJpdmVyU2VydmljZUxhdW5jaGVyIHtcbiAgICBwcml2YXRlIF9jYWNoZVBhdGg6IHN0cmluZ1xuICAgIHByaXZhdGUgX3ZzY29kZVNlcnZlclBvcnQ/OiBudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgcHJpdmF0ZSBfb3B0aW9uczogU2VydmljZU9wdGlvbnMsXG4gICAgICAgIHByaXZhdGUgX2NhcGFiaWxpdGllczogQ2FwYWJpbGl0aWVzLkNhcGFiaWxpdGllcyxcbiAgICAgICAgY29uZmlnOiBPcHRpb25zLlRlc3RydW5uZXJcbiAgICApIHtcbiAgICAgICAgc3VwZXIoX29wdGlvbnMsIF9jYXBhYmlsaXRpZXMsIGNvbmZpZylcbiAgICAgICAgdGhpcy5fY2FjaGVQYXRoID0gdGhpcy5fb3B0aW9ucy5jYWNoZVBhdGggfHwgREVGQVVMVF9DQUNIRV9QQVRIXG4gICAgICAgIHRoaXMuX21hcENhcGFiaWxpdGllcyA9ICgpID0+IHt9XG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIHNlcnZpY2UgdXNlcyBwcm92aWRlZCBwYXJhbXNcbiAgICBhc3luYyBvblByZXBhcmUgKF86IG5ldmVyLCBjYXBhYmlsaXRpZXM6IENhcGFiaWxpdGllcy5SZW1vdGVDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgY29uc3QgY2FwczogVlNDb2RlQ2FwYWJpbGl0aWVzW10gPSBBcnJheS5pc0FycmF5KGNhcGFiaWxpdGllcylcbiAgICAgICAgICAgID8gY2FwYWJpbGl0aWVzLm1hcCgoYykgPT4gKChjIGFzIENhcGFiaWxpdGllcy5XM0NDYXBhYmlsaXRpZXMpLmFsd2F5c01hdGNoIHx8IGMpIGFzIFZTQ29kZUNhcGFiaWxpdGllcylcbiAgICAgICAgICAgIDogT2JqZWN0LnZhbHVlcyhjYXBhYmlsaXRpZXMpLm1hcCgoYykgPT4gYy5jYXBhYmlsaXRpZXMgYXMgVlNDb2RlQ2FwYWJpbGl0aWVzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiBmb3IgZ2l2ZW4gdmVyc2lvbiB3ZSBhbHJlYWR5IGhhdmUgYWxsIGJ1bmRsZXNcbiAgICAgICAgICogYW5kIGNvbnRpbnVlIHdpdGhvdXQgZG93bmxvYWQgaWYgcG9zc2libGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBWRVJTSU9OU19UWFQpXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZUV4aXN0ID0gYXdhaXQgZmlsZUV4aXN0KHZlcnNpb25zRmlsZVBhdGgpXG5cbiAgICAgICAgZm9yIChjb25zdCBjYXAgb2YgY2Fwcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBza2lwIHNldHVwIGlmIHVzZXIgaXMgbm90IHVzaW5nIFZTQ29kZSBhcyBjYXBhYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwLmJyb3dzZXJOYW1lICE9PSAnc3RyaW5nJyB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0udmVyc2lvbiB8fCBjYXAuYnJvd3NlclZlcnNpb24gfHwgREVGQVVMVF9DSEFOTkVMXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2V0dXAgVlNDb2RlIERlc2t0b3BcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNhcC5icm93c2VyTmFtZSA9PT0gJ3ZzY29kZScpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFZTQ29kZURlc2t0b3AodmVyc2lvbnNGaWxlRXhpc3QsIHZlcnNpb25zRmlsZVBhdGgsIHZlcnNpb24sIGNhcClcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldHVwIFZTQ29kZSBXZWJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBWU0NvZGVXZWIodmVyc2lvbiwgY2FwKVxuICAgICAgICAgICAgdGhpcy5fbWFwQnJvd3NlckNhcGFiaWxpdGllcyh0aGlzLm9wdGlvbnMgYXMgU2VydmljZU9wdGlvbnMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIub25QcmVwYXJlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciB3ZWIgdGVzdGluZ1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVFeGlzdCB0cnVlIGlmIHdlIGFscmVhZHkgaGF2ZSBpbmZvcm1hdGlvbiBzdG9yZWQgYWJvdXQgY2FjaGVkIFZTQ29kZSBhbmQgQ2hyb21lZHJpdmVyIGJ1bmRsZXNcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlUGF0aCBzdHJpbmcgd2l0aCBwYXRoIHRvIGNhY2hlZCBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gY2FwIGNhcGFiaWxpdGllcyB1c2VkIGZvciB0aGlzIHRlc3QgcnVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBWU0NvZGVXZWIgKFxuICAgICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNhcDogVlNDb2RlQ2FwYWJpbGl0aWVzXG4gICAgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBubyBuZWVkIHRvIGRvIGFueSB3b3JrIGlmIHdlIGFscmVhZHkgc3RhcnRlZCB0aGUgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fdnNjb2RlU2VydmVyUG9ydCB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVN0YW5kYWxvbmUgPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVdlYlN0YW5kYWxvbmUodmVyc2lvbilcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBhd2FpdCBzdGFydFNlcnZlcih2c2NvZGVTdGFuZGFsb25lLCBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSlcbiAgICAgICAgICAgIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZTogREVGQVVMVF9WU0NPREVfV0VCX0hPU1ROQU1FXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcG9ydFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc3RhcnQgc2VydmVyIGZvciBWU0NvZGUgV2ViOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciBkZXNrdG9wIHRlc3RpbmdcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlRXhpc3QgdHJ1ZSBpZiB3ZSBhbHJlYWR5IGhhdmUgaW5mb3JtYXRpb24gc3RvcmVkIGFib3V0IGNhY2hlZCBWU0NvZGUgYW5kIENocm9tZWRyaXZlciBidW5kbGVzXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZVBhdGggc3RyaW5nIHdpdGggcGF0aCB0byBjYWNoZWQgZGlyZWN0b3J5XG4gICAgICogQHBhcmFtIGNhcCBjYXBhYmlsaXRpZXMgdXNlZCBmb3IgdGhpcyB0ZXN0IHJ1blxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX3NldHVwVlNDb2RlRGVza3RvcCAoXG4gICAgICAgIHZlcnNpb25zRmlsZUV4aXN0OiBib29sZWFuLFxuICAgICAgICB2ZXJzaW9uc0ZpbGVQYXRoOiBzdHJpbmcsXG4gICAgICAgIHZlcnNpb246IHN0cmluZyxcbiAgICAgICAgY2FwOiBWU0NvZGVDYXBhYmlsaXRpZXNcbiAgICApIHtcbiAgICAgICAgaWYgKCFjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBrZXkgXCIke1ZTQ09ERV9DQVBBQklMSVRZX0tFWX1cIiBmb3VuZCBpbiBjYXBzYClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJzaW9uc0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoKGF3YWl0IGZzLnJlYWRGaWxlKHZlcnNpb25zRmlsZVBhdGgpKS50b1N0cmluZygpKSBhcyBWZXJzaW9uc1xuICAgICAgICAgICAgY29uc3QgY2hyb21lZHJpdmVyUGF0aCA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGBjaHJvbWVkcml2ZXItJHtjb250ZW50W3ZlcnNpb25dPy5jaHJvbWVkcml2ZXJ9YClcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVBhdGggPSAoXG4gICAgICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0/LmJpbmFyeVxuICAgICAgICAgICAgICAgIHx8IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGB2c2NvZGUtJHtwcm9jZXNzLnBsYXRmb3JtfS0ke3Byb2Nlc3MuYXJjaH0tJHtjb250ZW50W3ZlcnNpb25dPy52c2NvZGV9YClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChjb250ZW50W3ZlcnNpb25dICYmIGF3YWl0IGZpbGVFeGlzdChjaHJvbWVkcml2ZXJQYXRoKSAmJiBhd2FpdCBmaWxlRXhpc3QodnNjb2RlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgYFNraXBwaW5nIGRvd25sb2FkLCBidW5kbGVzIGZvciBWU0NvZGUgdiR7Y29udGVudFt2ZXJzaW9uXT8udnNjb2RlfSBgXG4gICAgICAgICAgICAgICAgICAgICsgYGFuZCBDaHJvbWVkcml2ZXIgdiR7Y29udGVudFt2ZXJzaW9uXT8uY2hyb21lZHJpdmVyfSBhbHJlYWR5IGV4aXN0YFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2FwLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5ID0gKFxuICAgICAgICAgICAgICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5iaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgfHwgYXdhaXQgdGhpcy5fZG93bmxvYWRWU0NvZGUoY29udGVudFt2ZXJzaW9uXT8udnNjb2RlIGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVkcml2ZXJDdXN0b21QYXRoID0gY2hyb21lZHJpdmVyUGF0aFxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW3ZzY29kZVZlcnNpb24sIGNocm9tZWRyaXZlclZlcnNpb24sIGNocm9tZWRyaXZlclBhdGhdID0gYXdhaXQgdGhpcy5fc2V0dXBDaHJvbWVkcml2ZXIodmVyc2lvbilcbiAgICAgICAgdGhpcy5jaHJvbWVkcml2ZXJDdXN0b21QYXRoID0gY2hyb21lZHJpdmVyUGF0aFxuICAgICAgICBjb25zdCBzZXJ2aWNlQXJnczogU2VydmljZUNhcGFiaWxpdHkgPSB7XG4gICAgICAgICAgICBjaHJvbWVkcml2ZXI6IHsgdmVyc2lvbjogY2hyb21lZHJpdmVyVmVyc2lvbiwgcGF0aDogY2hyb21lZHJpdmVyUGF0aCB9LFxuICAgICAgICAgICAgdnNjb2RlOiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdnNjb2RlVmVyc2lvbixcbiAgICAgICAgICAgICAgICBwYXRoOiBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXT8uYmluYXJ5IHx8IGF3YWl0IHRoaXMuX2Rvd25sb2FkVlNDb2RlKHZzY29kZVZlcnNpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjYXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5ID0gc2VydmljZUFyZ3MudnNjb2RlLnBhdGhcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlVmVyc2lvbnNUeHQodmVyc2lvbiwgc2VydmljZUFyZ3MsIHZlcnNpb25zRmlsZUV4aXN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBDaHJvbWVkcml2ZXIgYnVuZGxlIGZvciBnaXZlbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEBwYXJhbSBkZXNpcmVkUmVsZWFzZUNoYW5uZWwgZWl0aGVyIHJlbGVhc2UgY2hhbm5lbCAoZS5nLiBcInN0YWJsZVwiIG9yIFwiaW5zaWRlcnNcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgY29uY3JldGUgdmVyc2lvbiBlLmcuIDEuNjYuMFxuICAgICAqIEByZXR1cm5zIFwiaW5zaWRlcnNcIiBpZiBgZGVzaXJlZFJlbGVhc2VDaGFubmVsYCBpcyBzZXQgdG8gdGhpcyBvdGhlcndpc2UgYSBjb25jcmV0ZSB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBDaHJvbWVkcml2ZXIgKGRlc2lyZWRSZWxlYXNlQ2hhbm5lbDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVZlcnNpb24oZGVzaXJlZFJlbGVhc2VDaGFubmVsKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaHJvbWVkcml2ZXJWZXJzaW9uID0gYXdhaXQgdGhpcy5fZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uKHZlcnNpb24pXG5cbiAgICAgICAgICAgIGxvZy5pbmZvKGBEb3dubG9hZCBDaHJvbWVkcml2ZXIgKHYke2Nocm9tZWRyaXZlclZlcnNpb259KWApXG4gICAgICAgICAgICBhd2FpdCBkb3dubG9hZEJ1bmRsZShcbiAgICAgICAgICAgICAgICBmb3JtYXQoQ0hST01FRFJJVkVSX0RPV05MT0FEX1BBVEgsIGNocm9tZWRyaXZlclZlcnNpb24sIHZhbGlkYXRlUGxhdGZvcm0oKSksXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVQYXRoLFxuICAgICAgICAgICAgICAgIHsgZXh0cmFjdDogdHJ1ZSwgc3RyaXA6IDEgfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCBleHQgPSBvcy5wbGF0Zm9ybSgpLnN0YXJ0c1dpdGgoJ3dpbicpID8gJy5leGUnIDogJydcbiAgICAgICAgICAgIGNvbnN0IGNocm9tZWRyaXZlclBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBgY2hyb21lZHJpdmVyLSR7Y2hyb21lZHJpdmVyVmVyc2lvbn0ke2V4dH1gKVxuICAgICAgICAgICAgYXdhaXQgZnMucmVuYW1lKHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGBjaHJvbWVkcml2ZXIke2V4dH1gKSwgY2hyb21lZHJpdmVyUGF0aClcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm4gJ2luc2lkZXJzJyBpZiBkZXNpcmVkIHJlbGVhc2UgY2hhbm5lbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA9PT0gJ21haW4nXG4gICAgICAgICAgICAgICAgPyBbZGVzaXJlZFJlbGVhc2VDaGFubmVsLCBjaHJvbWVkcml2ZXJWZXJzaW9uLCBjaHJvbWVkcml2ZXJQYXRoXVxuICAgICAgICAgICAgICAgIDogW3ZlcnNpb24sIGNocm9tZWRyaXZlclZlcnNpb24sIGNocm9tZWRyaXZlclBhdGhdXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBzZXQgdXAgQ2hyb21lZHJpdmVyICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIFZTQ29kZSBidW5kbGVcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEByZXR1cm5zIHBhdGggdG8gZG93bmxvYWRlZCBWU0NvZGUgYnVuZGxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZG93bmxvYWRWU0NvZGUgKHZlcnNpb246IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nLmluZm8oYERvd25sb2FkIFZTQ29kZSBiaW5hcnkgKCR7dmVyc2lvbn0pYClcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkb3dubG9hZCh7XG4gICAgICAgICAgICAgICAgY2FjaGVQYXRoOiB0aGlzLl9jYWNoZVBhdGgsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IHNldCB1cCBWU0NvZGU6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBWU0NvZGUgdmVyc2lvbiBiYXNlZCBvbiBkZXNpcmVkIGNoYW5uZWwgb3IgdmFsaWRhdGUgdmVyc2lvbiBpZiBwcm92aWRlZFxuICAgICAqIEBwYXJhbSBkZXNpcmVkUmVsZWFzZUNoYW5uZWwgZWl0aGVyIHJlbGVhc2UgY2hhbm5lbCAoZS5nLiBcInN0YWJsZVwiIG9yIFwiaW5zaWRlcnNcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgY29uY3JldGUgdmVyc2lvbiBlLmcuIDEuNjYuMFxuICAgICAqIEByZXR1cm5zIFwibWFpblwiIGlmIGBkZXNpcmVkUmVsZWFzZUNoYW5uZWxgIGlzIFwiaW5zaWRlcnNcIiBvdGhlcndpc2UgYSBjb25jcmV0ZSBWU0NvZGUgdmVyc2lvblxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2ZldGNoVlNDb2RlVmVyc2lvbiAoZGVzaXJlZFJlbGVhc2VDaGFubmVsPzogc3RyaW5nIHwgc3RyaW5nKSB7XG4gICAgICAgIGlmIChkZXNpcmVkUmVsZWFzZUNoYW5uZWwgPT09ICdpbnNpZGVycycpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFpbidcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgRmV0Y2ggcmVsZWFzZXMgZnJvbSAke1ZTQ09ERV9SRUxFQVNFU31gKVxuICAgICAgICAgICAgY29uc3QgeyBib2R5OiB2ZXJzaW9ucyB9ID0gYXdhaXQgcmVxdWVzdChWU0NPREVfUkVMRUFTRVMsIHt9KVxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlVmVyc2lvbnM6IHN0cmluZ1tdID0gYXdhaXQgdmVyc2lvbnMuanNvbigpXG5cbiAgICAgICAgICAgIGlmIChkZXNpcmVkUmVsZWFzZUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB2YWxpZGF0ZSBwcm92aWRlZCBWU0NvZGUgdmVyc2lvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ3N0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgPyBhdmFpbGFibGVWZXJzaW9uc1swXVxuICAgICAgICAgICAgICAgICAgICA6IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbFxuICAgICAgICAgICAgICAgIGlmICghYXZhaWxhYmxlVmVyc2lvbnMuaW5jbHVkZXMobmV3RGVzaXJlZFJlbGVhc2VDaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRGVzaXJlZCB2ZXJzaW9uIFwiJHtuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWx9XCIgaXMgbm90IGV4aXN0ZW50LCBhdmFpbGFibGUgdmVyc2lvbnM6YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHthdmFpbGFibGVWZXJzaW9ucy5zbGljZSgwLCA1KS5qb2luKCcsICcpfS4uLiwgc2VlICR7VlNDT0RFX1JFTEVBU0VTfWBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBmZXRjaCBsYXRlc3QgVlNDb2RlOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uIGZvciBnaXZlbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEBwYXJhbSB2c2NvZGVWZXJzaW9uIGJyYW5jaCBvciB0YWcgdmVyc2lvbiBvZiBWU0NvZGUgcmVwb3NpdG9yeVxuICAgICAqIEByZXR1cm5zIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uICh2c2NvZGVWZXJzaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gYXdhaXQgcmVxdWVzdChmb3JtYXQoVlNDT0RFX01BTklGRVNUX1VSTCwgdnNjb2RlVmVyc2lvbiksIHt9KVxuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3Q6IE1hbmlmZXN0ID0gYXdhaXQgYm9keS5qc29uKClcbiAgICAgICAgICAgIGNvbnN0IGNocm9taXVtID0gbWFuaWZlc3QucmVnaXN0cmF0aW9ucy5maW5kKChyOiBhbnkpID0+IHIuY29tcG9uZW50LmdpdC5uYW1lID09PSAnY2hyb21pdW0nKVxuXG4gICAgICAgICAgICBpZiAoIWNocm9taXVtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGZpbmQgY2hyb21pdW0gdmVyc2lvbiBpbiBtYW5pZmVzdCByZXNwb25zZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgYm9keTogY2hyb21lZHJpdmVyVmVyc2lvbiB9ID0gYXdhaXQgcmVxdWVzdChcbiAgICAgICAgICAgICAgICBmb3JtYXQoQ0hST01FRFJJVkVSX1JFTEVBU0VTLCBjaHJvbWl1bS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY2hyb21lZHJpdmVyVmVyc2lvbi50ZXh0KClcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IGZldGNoIENocm9tZWRyaXZlciB2ZXJzaW9uOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIFZTQ29kZSBXZWIgZmlsZXNcbiAgICAgKiBUb0RvKENocmlzdGlhbik6IGFsbG93IHRvIGRlZmluZSBhIGxvY2FsIFZTQ29kZSBkZXZlbG9wbWVudCBwYXRoXG4gICAgICogICAgICAgICAgICAgICAgICB0byBiZSBhYmxlIHRvIHNraXAgdGhpcyBwYXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hWU0NvZGVXZWJTdGFuZGFsb25lICh2c2NvZGVWZXJzaW9uOiBzdHJpbmcpOiBQcm9taXNlPEJ1bmRsZT4ge1xuICAgICAgICBpZiAodnNjb2RlVmVyc2lvbiAhPT0gJ3N0YWJsZScgJiYgdnNjb2RlVmVyc2lvbiAhPT0gJ2luc2lkZXJzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdW5uaW5nIFZTQ29kZSBpbiB0aGUgYnJvd3NlciBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgXCJzdGFibGVcIiBhbmQgXCJpbnNpZGVyc1wiIHZlcnNpb24nKVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gYXdhaXQgcmVxdWVzdChmb3JtYXQoVlNDT0RFX1dFQl9TVEFOREFMT05FLCB2c2NvZGVWZXJzaW9uKSwge30pXG4gICAgICAgICAgICBjb25zdCBpbmZvOiBXZWJTdGFuZGFsb25lUmVzcG9uc2UgPSBhd2FpdCBib2R5Lmpzb24oKVxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgYHZzY29kZS13ZWItJHt2c2NvZGVWZXJzaW9ufS0ke2luZm8udmVyc2lvbn1gKVxuXG4gICAgICAgICAgICBpZiAoIShhd2FpdCBkaXJlY3RvcnlFeGlzdHMoZm9sZGVyKSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkb3dubG9hZEJ1bmRsZShpbmZvLnVybCwgZm9sZGVyLCB7IGV4dHJhY3Q6IHRydWUsIHN0cmlwOiAxIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZvbGRlciwgdnNjb2RlVmVyc2lvbiwgdmVyc2lvbjogaW5mby52ZXJzaW9uIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IHNldCB1cCBWU0NvZGUgV2ViOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF91cGRhdGVWZXJzaW9uc1R4dCAodmVyc2lvbjogc3RyaW5nLCBzZXJ2aWNlQXJnczogU2VydmljZUNhcGFiaWxpdHksIHZlcnNpb25zRmlsZUV4aXN0OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRlbnQ6IFZlcnNpb25zID0ge1xuICAgICAgICAgICAgW3ZlcnNpb25dOiB7XG4gICAgICAgICAgICAgICAgY2hyb21lZHJpdmVyOiBzZXJ2aWNlQXJncy5jaHJvbWVkcml2ZXIudmVyc2lvbixcbiAgICAgICAgICAgICAgICB2c2NvZGU6IHNlcnZpY2VBcmdzLnZzY29kZS52ZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbnNUeHRQYXRoID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgVkVSU0lPTlNfVFhUKVxuICAgICAgICBpZiAoIXZlcnNpb25zRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnMud3JpdGVGaWxlKFxuICAgICAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXdDb250ZW50LCBudWxsLCA0KSxcbiAgICAgICAgICAgICAgICAndXRmLTgnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSgoYXdhaXQgZnMucmVhZEZpbGUodmVyc2lvbnNUeHRQYXRoLCAndXRmLTgnKSkudG9TdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShcbiAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgLi4uY29udGVudCwgLi4ubmV3Q29udGVudCB9LCBudWxsLCA0KSxcbiAgICAgICAgICAgICd1dGYtOCdcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHByaXZhdGUgX21hcEJyb3dzZXJDYXBhYmlsaXRpZXMgKG9wdGlvbnM6IFNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgIGlmIChpc011bHRpcmVtb3RlKHRoaXMuX2NhcGFiaWxpdGllcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoJ1RoaXMgc2VydmljZSBkZXNvblxcJ3Qgc3VwcG9ydCBtdWx0aXJlbW90ZSB5ZXQnKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBjYXAgb2YgdGhpcy5fY2FwYWJpbGl0aWVzIGFzIGFueSBhcyBDYXBhYmlsaXRpZXMuQ2FwYWJpbGl0aWVzW10pIHtcbiAgICAgICAgICAgIGlmIChpc0Nocm9tZShjYXApKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjYXAsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=