var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BasePage, ElementWithContextMenu, PageDecorator } from '../utils.js';
import { ViewSection as ViewSectionLocators } from '../../locators/1.73.0.js';
/**
 * Arbitrary item in the side bar view
 *
 * @category Sidebar
 */
export class ViewItem extends ElementWithContextMenu {
    /**
     * Select the item in the view.
     * Note that selecting the item will toggle its expand state when applicable.
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
}
/**
 * TreeItem abstract class
 *
 * @category Sidebar
 */
export class TreeItem extends ViewItem {
    /**
     * Finds if the item has children by actually counting the child items
     * Note that this will expand the item if it was collapsed
     * @returns Promise resolving to true/false
     */
    async hasChildren() {
        const children = await this.getChildren();
        return children && children.length > 0;
    }
    /**
     * Expands the current item, if it can be expanded and is collapsed.
     */
    async expand() {
        if (await this.isExpandable() && !await this.isExpanded()) {
            await this.twistie$.click();
        }
    }
    /**
     * Find a child item with the given name
     * @returns Promise resolving to TreeItem object if the child item exists, undefined otherwise
     */
    async findChildItem(name) {
        const children = await this.getChildren();
        for (const item of children) {
            if (await item.getLabel() === name) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Collapse the item if expanded
     */
    async collapse() {
        if (await this.isExpandable() && await this.isExpanded()) {
            await this.twistie$.click();
        }
    }
    /**
     * Find all action buttons bound to the view item
     *
     * @returns array of ViewItemAction objects, empty array if item has no
     * actions associated
     */
    async getActionButtons() {
        await this.elem.moveTo();
        const container = await this.actions$;
        if (!await container.isExisting()) {
            return [];
        }
        const actions = [];
        const items = await container.$$(this.locators.actionLabel);
        for (const item of items) {
            const elem = item.$(this.locatorMap.ViewSection.actionConstructor());
            const label = (
            // v1.69.0 and before
            await elem.getAttribute(this.locators.actionTitle)
                // v1.70.0 and after
                || await item.getAttribute(this.locators.actionTitle));
            actions.push(new ViewItemAction(this.locatorMap, elem, label, this));
        }
        return actions;
    }
    /**
     * Find action button for view item by label
     * @param label label of the button to search by
     *
     * @returns ViewItemAction object if such button exists, undefined otherwise
     */
    async getActionButton(label) {
        const actions = await this.getActionButtons();
        if (actions.length > 0) {
            return actions.find((item) => item.getLabel().indexOf(label) > -1);
        }
        return undefined;
    }
    /**
     * Find all child elements of a tree item
     * @param locator locator of a given type of tree item
     */
    async getChildItems(locator) {
        const items = [];
        await this.expand();
        const rows = await this.parent.$$(locator);
        const baseIndex = +await this.elem.getAttribute(this.locatorMap.ViewSection.index);
        const baseLevel = +await this.elem.getAttribute(this.locatorMap.ViewSection.level);
        for (const row of rows) {
            const level = +await row.getAttribute(this.locatorMap.ViewSection.level);
            const index = +await row.getAttribute(this.locatorMap.ViewSection.index);
            if (index <= baseIndex) {
                continue;
            }
            if (level > baseLevel + 1) {
                continue;
            }
            if (level <= baseLevel) {
                break;
            }
            items.push(row);
        }
        return items;
    }
    async findTwistie() {
        return this.twistie$;
    }
}
/**
 * Action button bound to a view item
 *
 * @category Sidebar
 */
let ViewItemAction = class ViewItemAction extends BasePage {
    constructor(locators, elem, label, viewItem) {
        super(locators, elem, viewItem.elem);
        /**
         * @private
         */
        this.locatorKey = 'ViewSection';
        this.label = label;
    }
    /**
     * Get label of the action button
     */
    getLabel() {
        return this.label;
    }
};
ViewItemAction = __decorate([
    PageDecorator(ViewSectionLocators)
], ViewItemAction);
export { ViewItemAction };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlld0l0ZW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvc2lkZWJhci9WaWV3SXRlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxPQUFPLEVBQ2EsUUFBUSxFQUFFLHNCQUFzQixFQUFFLGFBQWEsRUFDbEUsTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUNILFdBQVcsSUFBSSxtQkFBbUIsRUFLckMsTUFBTSwwQkFBMEIsQ0FBQTtBQWVqQzs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQixRQUFTLFNBQVEsc0JBQXdDO0lBQzNFOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsTUFBTTtRQUNSLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtJQUMzQixDQUFDO0NBQ0o7QUFHRDs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQixRQUFTLFNBQVEsUUFBUTtJQWtCM0M7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2IsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDekMsT0FBTyxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7SUFDMUMsQ0FBQztJQW9CRDs7T0FFRztJQUNILEtBQUssQ0FBQyxNQUFNO1FBQ1IsSUFBSSxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3ZELE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtTQUM5QjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFFLElBQVk7UUFDN0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7UUFDekMsS0FBSyxNQUFNLElBQUksSUFBSSxRQUFRLEVBQUU7WUFDekIsSUFBSSxN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d2ViZHJpdmVyaW8nXG5pbXBvcnQge1xuICAgIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSwgRWxlbWVudFdpdGhDb250ZXh0TWVudSwgUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcFxufSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7XG4gICAgVmlld1NlY3Rpb24gYXMgVmlld1NlY3Rpb25Mb2NhdG9ycyxcbiAgICBUcmVlSXRlbSBhcyBUcmVlSXRlbUxvY2F0b3JzLFxuICAgIEN1c3RvbVRyZWVJdGVtIGFzIEN1c3RvbVRyZWVJdGVtTG9jYXRvcnMsXG4gICAgRGVmYXVsdFRyZWVJdGVtIGFzIERlZmF1bHRUcmVlSXRlbUxvY2F0b3JzLFxuICAgIEV4dGVuc2lvbnNWaWV3SXRlbSBhcyBFeHRlbnNpb25zVmlld0l0ZW1Mb2NhdG9yc1xufSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5cbi8qKlxuICogQWJzdHJhY3QgcmVwcmVzZW50YXRpb24gb2YgYSByb3cgaW4gdGhlIHRyZWUgaW5zaWRlIGEgdmlldyBjb250ZW50IHNlY3Rpb25cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IHR5cGUgVmlld0l0ZW1Mb2NhdG9ycyA9IChcbiAgICB0eXBlb2YgVmlld1NlY3Rpb25Mb2NhdG9ycyAmXG4gICAgdHlwZW9mIFRyZWVJdGVtTG9jYXRvcnMgJlxuICAgIHR5cGVvZiBDdXN0b21UcmVlSXRlbUxvY2F0b3JzICZcbiAgICB0eXBlb2YgRGVmYXVsdFRyZWVJdGVtTG9jYXRvcnMgJlxuICAgIHR5cGVvZiBFeHRlbnNpb25zVmlld0l0ZW1Mb2NhdG9yc1xuKVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdJdGVtIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8Vmlld0l0ZW1Mb2NhdG9ycz4geyB9XG4vKipcbiAqIEFyYml0cmFyeSBpdGVtIGluIHRoZSBzaWRlIGJhciB2aWV3XG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZpZXdJdGVtIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTxWaWV3SXRlbUxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBpdGVtIGluIHRoZSB2aWV3LlxuICAgICAqIE5vdGUgdGhhdCBzZWxlY3RpbmcgdGhlIGl0ZW0gd2lsbCB0b2dnbGUgaXRzIGV4cGFuZCBzdGF0ZSB3aGVuIGFwcGxpY2FibGUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaXRlbSBoYXMgYmVlbiBjbGlja2VkXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0ICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUl0ZW0gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjxWaWV3SXRlbUxvY2F0b3JzPiB7IH1cbi8qKlxuICogVHJlZUl0ZW0gYWJzdHJhY3QgY2xhc3NcbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJlZUl0ZW0gZXh0ZW5kcyBWaWV3SXRlbSB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsYWJlbCBvZiB0aGlzIHZpZXcgaXRlbVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldExhYmVsICgpOiBQcm9taXNlPHN0cmluZz5cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdG9vbHRpcCBvZiB0aGlzIFRyZWVJdGVtLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRvb2x0aXAgb3IgdW5kZWZpbmVkIGlmIHRoZSBUcmVlSXRlbSBoYXMgbm8gdG9vbHRpcC5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRUb29sdGlwICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD5cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGVzY3JpcHRpb24gb2YgdGhpcyBUcmVlSXRlbS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b29sdGlwIG9yIHVuZGVmaW5lZCBpZiB0aGUgVHJlZUl0ZW0gaGFzIG5vIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldERlc2NyaXB0aW9uICgpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD5cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGlmIHRoZSBpdGVtIGhhcyBjaGlsZHJlbiBieSBhY3R1YWxseSBjb3VudGluZyB0aGUgY2hpbGQgaXRlbXNcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGV4cGFuZCB0aGUgaXRlbSBpZiBpdCB3YXMgY29sbGFwc2VkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZS9mYWxzZVxuICAgICAqL1xuICAgIGFzeW5jIGhhc0NoaWxkcmVuICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBhd2FpdCB0aGlzLmdldENoaWxkcmVuKClcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB3aGV0aGVyIHRoZSBpdGVtIGlzIGV4cGFuZGVkLiBBbHdheXMgcmV0dXJucyBmYWxzZSBpZiBpdGVtIGhhcyBubyBjaGlsZHJlbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlL2ZhbHNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgaXNFeHBhbmRlZCAoKTogUHJvbWlzZTxib29sZWFuPlxuXG4gICAgLyoqXG4gICAgICogRmluZCBjaGlsZHJlbiBvZiBhbiBpdGVtLCB3aWxsIHRyeSB0byBleHBhbmQgdGhlIGl0ZW0gaW4gdGhlIHByb2Nlc3NcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBUcmVlSXRlbSBvYmplY3RzLCBlbXB0eSBhcnJheSBpZiBpdGVtIGhhcyBubyBjaGlsZHJlblxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldENoaWxkcmVuICgpOiBQcm9taXNlPFRyZWVJdGVtW10+XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpZiB0aGUgaXRlbSBpcyBleHBhbmRhYmxlL2NvbGxhcHNpYmxlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZS9mYWxzZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGlzRXhwYW5kYWJsZSAoKTogUHJvbWlzZTxib29sZWFuPlxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgY3VycmVudCBpdGVtLCBpZiBpdCBjYW4gYmUgZXhwYW5kZWQgYW5kIGlzIGNvbGxhcHNlZC5cbiAgICAgKi9cbiAgICBhc3luYyBleHBhbmQgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc0V4cGFuZGFibGUoKSAmJiAhYXdhaXQgdGhpcy5pc0V4cGFuZGVkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudHdpc3RpZSQuY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGNoaWxkIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIFRyZWVJdGVtIG9iamVjdCBpZiB0aGUgY2hpbGQgaXRlbSBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kQ2hpbGRJdGVtIChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFRyZWVJdGVtIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgdGhpcy5nZXRDaGlsZHJlbigpXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGl0ZW0uZ2V0TGFiZWwoKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIHRoZSBpdGVtIGlmIGV4cGFuZGVkXG4gICAgICovXG4gICAgYXN5bmMgY29sbGFwc2UgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc0V4cGFuZGFibGUoKSAmJiBhd2FpdCB0aGlzLmlzRXhwYW5kZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50d2lzdGllJC5jbGljaygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCBhY3Rpb24gYnV0dG9ucyBib3VuZCB0byB0aGUgdmlldyBpdGVtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBWaWV3SXRlbUFjdGlvbiBvYmplY3RzLCBlbXB0eSBhcnJheSBpZiBpdGVtIGhhcyBub1xuICAgICAqIGFjdGlvbnMgYXNzb2NpYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGlvbkJ1dHRvbnMgKCk6IFByb21pc2U8Vmlld0l0ZW1BY3Rpb25bXT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmVsZW0ubW92ZVRvKClcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgdGhpcy5hY3Rpb25zJFxuXG4gICAgICAgIGlmICghYXdhaXQgY29udGFpbmVyLmlzRXhpc3RpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY3Rpb25zOiBWaWV3SXRlbUFjdGlvbltdID0gW11cbiAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBjb250YWluZXIuJCQodGhpcy5sb2NhdG9ycy5hY3Rpb25MYWJlbClcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlbS4kKCh0aGlzLmxvY2F0b3JNYXAuVmlld1NlY3Rpb24uYWN0aW9uQ29uc3RydWN0b3IgYXMgKCkgPT4gc3RyaW5nKSgpKVxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSAoXG4gICAgICAgICAgICAgICAgLy8gdjEuNjkuMCBhbmQgYmVmb3JlXG4gICAgICAgICAgICAgICAgYXdhaXQgZWxlbS5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhdG9ycy5hY3Rpb25UaXRsZSlcbiAgICAgICAgICAgICAgICAvLyB2MS43MC4wIGFuZCBhZnRlclxuICAgICAgICAgICAgICAgIHx8IGF3YWl0IGl0ZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvcnMuYWN0aW9uVGl0bGUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBhY3Rpb25zLnB1c2gobmV3IFZpZXdJdGVtQWN0aW9uKHRoaXMubG9jYXRvck1hcCwgZWxlbSwgbGFiZWwsIHRoaXMpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhY3Rpb24gYnV0dG9uIGZvciB2aWV3IGl0ZW0gYnkgbGFiZWxcbiAgICAgKiBAcGFyYW0gbGFiZWwgbGFiZWwgb2YgdGhlIGJ1dHRvbiB0byBzZWFyY2ggYnlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFZpZXdJdGVtQWN0aW9uIG9iamVjdCBpZiBzdWNoIGJ1dHRvbiBleGlzdHMsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb25CdXR0b24gKGxhYmVsOiBzdHJpbmcpOiBQcm9taXNlPFZpZXdJdGVtQWN0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmdldEFjdGlvbkJ1dHRvbnMoKVxuICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5maW5kKChpdGVtKSA9PiBpdGVtLmdldExhYmVsKCkuaW5kZXhPZihsYWJlbCkgPiAtMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgY2hpbGQgZWxlbWVudHMgb2YgYSB0cmVlIGl0ZW1cbiAgICAgKiBAcGFyYW0gbG9jYXRvciBsb2NhdG9yIG9mIGEgZ2l2ZW4gdHlwZSBvZiB0cmVlIGl0ZW1cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYXN5bmMgZ2V0Q2hpbGRJdGVtcyAobG9jYXRvcjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zOiBXZWJkcml2ZXJJTy5FbGVtZW50W10gPSBbXVxuICAgICAgICBhd2FpdCB0aGlzLmV4cGFuZCgpXG5cbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMucGFyZW50LiQkKGxvY2F0b3IpXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9ICthd2FpdCB0aGlzLmVsZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvck1hcC5WaWV3U2VjdGlvbi5pbmRleCBhcyBzdHJpbmcpXG4gICAgICAgIGNvbnN0IGJhc2VMZXZlbCA9ICthd2FpdCB0aGlzLmVsZW0uZ2V0QXR0cmlidXRlKHRoaXMubG9jYXRvck1hcC5WaWV3U2VjdGlvbi5sZXZlbCBhcyBzdHJpbmcpXG5cbiAgICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSArYXdhaXQgcm93LmdldEF0dHJpYnV0ZSh0aGlzLmxvY2F0b3JNYXAuVmlld1NlY3Rpb24ubGV2ZWwgYXMgc3RyaW5nKVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSArYXdhaXQgcm93LmdldEF0dHJpYnV0ZSh0aGlzLmxvY2F0b3JNYXAuVmlld1NlY3Rpb24uaW5kZXggYXMgc3RyaW5nKVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPD0gYmFzZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXZlbCA+IGJhc2VMZXZlbCArIDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxldmVsIDw9IGJhc2VMZXZlbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2gocm93KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIGZpbmRUd2lzdGllICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHdpc3RpZSRcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0l0ZW1BY3Rpb24gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgVmlld1NlY3Rpb25Mb2NhdG9ycz4geyB9XG4vKipcbiAqIEFjdGlvbiBidXR0b24gYm91bmQgdG8gYSB2aWV3IGl0ZW1cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihWaWV3U2VjdGlvbkxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFZpZXdJdGVtQWN0aW9uIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFZpZXdTZWN0aW9uTG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1ZpZXdTZWN0aW9uJyBhcyBjb25zdFxuICAgIHByaXZhdGUgbGFiZWw6IHN0cmluZ1xuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbTogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgIHZpZXdJdGVtOiBUcmVlSXRlbVxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbSwgdmlld0l0ZW0uZWxlbSlcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhYmVsIG9mIHRoZSBhY3Rpb24gYnV0dG9uXG4gICAgICovXG4gICAgZ2V0TGFiZWwgKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsXG4gICAgfVxufVxuIl19