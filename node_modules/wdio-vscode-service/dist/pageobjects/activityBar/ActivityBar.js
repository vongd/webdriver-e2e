var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { ViewControl, ActionsControl } from '../index.js';
import { PageDecorator, ElementWithContextMenu } from '../utils.js';
import { ActivityBar as ActivityBarLocators } from '../../locators/1.73.0.js';
/**
 * Page object representing the left side activity bar in VS Code
 *
 * @category ActivityBar
 */
let ActivityBar = class ActivityBar extends ElementWithContextMenu {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ActivityBar';
    }
    /**
     * Find all view containers displayed in the activity bar
     * @returns Promise resolving to array of ViewControl objects
     */
    async getViewControls() {
        const views = [];
        const viewContainer = await this.viewContainer$;
        for (const element of await viewContainer.$$(this.locators.actionItem)) {
            views.push(await new ViewControl(this.locatorMap, 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            element, this).wait());
        }
        return views;
    }
    /**
     * Find a view container with a given title
     * @param name title of the view
     * @returns Promise resolving to ViewControl object representing the view selector, undefined if not found
     */
    async getViewControl(name) {
        const controls = await this.getViewControls();
        const names = await Promise.all(controls.map(async (item) => item.getTitle()));
        const index = names.findIndex((value) => value.indexOf(name) > -1);
        if (index > -1) {
            return controls[index];
        }
        return undefined;
    }
    /**
     * Returns selected view control
     * @returns Promise resolving to selected ViewControl object
     */
    async getSelectedViewAction() {
        const element = await this.viewContainer$.$(this.locators.actionItemSelected);
        return new ViewControl(this.locatorMap, 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        element, this).wait();
    }
    /**
     * Find all global action controls displayed on the bottom of the activity bar
     * @returns Promise resolving to array of ActionsControl objects
     */
    async getGlobalActions() {
        const actions = [];
        const actionContainer = await this.actionsContainer$;
        for (const element of await actionContainer.$$(this.locators.actionItem)) {
            actions.push(await new ActionsControl(this.locatorMap, 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            element).wait());
        }
        return actions;
    }
    /**
     * Find an action control with a given title
     * @param name title of the global action
     * @returns Promise resolving to ActionsControl object representing the action selector, undefined if not found
     */
    async getGlobalAction(name) {
        const actions = await this.getGlobalActions();
        const names = await Promise.all(actions.map(async (item) => item.getTitle()));
        const index = names.findIndex((value) => value.indexOf(name) > -1);
        if (index > -1) {
            return actions[index];
        }
        return undefined;
    }
};
ActivityBar = __decorate([
    PageDecorator(ActivityBarLocators)
], ActivityBar);
export { ActivityBar };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWN0aXZpdHlCYXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvYWN0aXZpdHlCYXIvQWN0aXZpdHlCYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDekQsT0FBTyxFQUFFLGFBQWEsRUFBa0Isc0JBQXNCLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDbkYsT0FBTyxFQUFFLFdBQVcsSUFBSSxtQkFBbUIsRUFBRSxNQUFNLDBCQUEwQixDQUFBO0FBRzdFOzs7O0dBSUc7QUFFSSxJQUFNLFdBQVcsR0FBakIsTUFBTSxXQUFZLFNBQVEsc0JBQWtEO0lBQTVFOztRQUNIOztXQUVHO1FBQ0ksZUFBVSxHQUFHLGFBQXNCLENBQUE7SUFrRjlDLENBQUM7SUFoRkc7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGVBQWU7UUFDakIsTUFBTSxLQUFLLEdBQWtCLEVBQUUsQ0FBQTtRQUMvQixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUE7UUFDL0MsS0FBSyxNQUFNLE9BQU8sSUFBSSxNQUFNLGFBQWEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNwRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxXQUFXLENBQzVCLElBQUksQ0FBQyxVQUFVO1lBQ2YsaUVBQWlFO1lBQ2pFLE9BQWMsRUFDZCxJQUFJLENBQ1AsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO1NBQ1o7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxjQUFjLENBQUUsSUFBWTtRQUM5QixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQTtRQUM3QyxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQzNCLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQ2hELENBQUE7UUFDRCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDbEUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDWixPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtTQUN6QjtRQUNELE9BQU8sU0FBUyxDQUFBO0lBQ3BCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMscUJBQXFCO1FBQ3ZCLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO1FBQzdFLE9BQU8sSUFBSSxXQUFXLENBQ2xCLElBQUksQ0FBQyxVQUFVO1FBQ2YsaUVBQWlFO1FBQ2pFLE9BQWMsRUFDZCxJQUFJLENBQ1AsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtJQUNaLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsZ0JBQWdCO1FBQ2xCLE1BQU0sT0FBTyxHQUFxQixFQUFFLENBQUE7UUFDcEMsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUE7UUFDcEQsS0FBSyxNQUFNLE9BQU8sSUFBSSxNQUFNLGVBQWUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN0RSxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxjQUFjLENBQ2pDLElBQUksQ0FBQyxVQUFVO1lBQ2YsaUVBQWlFO1lBQ2pFLE9BQWMsQ0FDakIsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO1NBQ1o7UUFDRCxPQUFPLE9BQU8sQ0FBQTtJQUNsQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQUUsSUFBWTtRQUMvQixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1FBQzdDLE1BQU0sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDN0UsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ2xFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ1osT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7U0FDeEI7UUFDRCxPQUFPLFNBQVMsQ0FBQTtJQUNwQixDQUFDO0NBQ0osQ0FBQTtBQXRGWSxXQUFXO0lBRHZCLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQztHQUN0QixXQUFXLENBc0Z2QjtTQXRGWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlld0NvbnRyb2wsIEFjdGlvbnNDb250cm9sIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgRWxlbWVudFdpdGhDb250ZXh0TWVudSB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgQWN0aXZpdHlCYXIgYXMgQWN0aXZpdHlCYXJMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eUJhciBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBBY3Rpdml0eUJhckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGxlZnQgc2lkZSBhY3Rpdml0eSBiYXIgaW4gVlMgQ29kZVxuICpcbiAqIEBjYXRlZ29yeSBBY3Rpdml0eUJhclxuICovXG5AUGFnZURlY29yYXRvcihBY3Rpdml0eUJhckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIEFjdGl2aXR5QmFyIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTx0eXBlb2YgQWN0aXZpdHlCYXJMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnQWN0aXZpdHlCYXInIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCB2aWV3IGNvbnRhaW5lcnMgZGlzcGxheWVkIGluIHRoZSBhY3Rpdml0eSBiYXJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBWaWV3Q29udHJvbCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Vmlld0NvbnRyb2xzICgpOiBQcm9taXNlPFZpZXdDb250cm9sW10+IHtcbiAgICAgICAgY29uc3Qgdmlld3M6IFZpZXdDb250cm9sW10gPSBbXVxuICAgICAgICBjb25zdCB2aWV3Q29udGFpbmVyID0gYXdhaXQgdGhpcy52aWV3Q29udGFpbmVyJFxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXdhaXQgdmlld0NvbnRhaW5lci4kJCh0aGlzLmxvY2F0b3JzLmFjdGlvbkl0ZW0pKSB7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKGF3YWl0IG5ldyBWaWV3Q29udHJvbChcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBlbGVtZW50IGFzIGFueSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLndhaXQoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3NcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgdmlldyBjb250YWluZXIgd2l0aCBhIGdpdmVuIHRpdGxlXG4gICAgICogQHBhcmFtIG5hbWUgdGl0bGUgb2YgdGhlIHZpZXdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBWaWV3Q29udHJvbCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB2aWV3IHNlbGVjdG9yLCB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Vmlld0NvbnRyb2wgKG5hbWU6IHN0cmluZyk6IFByb21pc2U8Vmlld0NvbnRyb2wgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBhd2FpdCB0aGlzLmdldFZpZXdDb250cm9scygpXG4gICAgICAgIGNvbnN0IG5hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjb250cm9scy5tYXAoYXN5bmMgKGl0ZW0pID0+IGl0ZW0uZ2V0VGl0bGUoKSlcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgodmFsdWUpID0+IHZhbHVlLmluZGV4T2YobmFtZSkgPiAtMSlcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sc1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWxlY3RlZCB2aWV3IGNvbnRyb2xcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzZWxlY3RlZCBWaWV3Q29udHJvbCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTZWxlY3RlZFZpZXdBY3Rpb24gKCk6IFByb21pc2U8Vmlld0NvbnRyb2w+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGF3YWl0IHRoaXMudmlld0NvbnRhaW5lciQuJCh0aGlzLmxvY2F0b3JzLmFjdGlvbkl0ZW1TZWxlY3RlZClcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q29udHJvbChcbiAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBlbGVtZW50IGFzIGFueSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCBnbG9iYWwgYWN0aW9uIGNvbnRyb2xzIGRpc3BsYXllZCBvbiB0aGUgYm90dG9tIG9mIHRoZSBhY3Rpdml0eSBiYXJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBBY3Rpb25zQ29udHJvbCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R2xvYmFsQWN0aW9ucyAoKTogUHJvbWlzZTxBY3Rpb25zQ29udHJvbFtdPiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnM6IEFjdGlvbnNDb250cm9sW10gPSBbXVxuICAgICAgICBjb25zdCBhY3Rpb25Db250YWluZXIgPSBhd2FpdCB0aGlzLmFjdGlvbnNDb250YWluZXIkXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBhd2FpdCBhY3Rpb25Db250YWluZXIuJCQodGhpcy5sb2NhdG9ycy5hY3Rpb25JdGVtKSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGF3YWl0IG5ldyBBY3Rpb25zQ29udHJvbChcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0b3JNYXAsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBlbGVtZW50IGFzIGFueVxuICAgICAgICAgICAgKS53YWl0KCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGFjdGlvbiBjb250cm9sIHdpdGggYSBnaXZlbiB0aXRsZVxuICAgICAqIEBwYXJhbSBuYW1lIHRpdGxlIG9mIHRoZSBnbG9iYWwgYWN0aW9uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gQWN0aW9uc0NvbnRyb2wgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYWN0aW9uIHNlbGVjdG9yLCB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R2xvYmFsQWN0aW9uIChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEFjdGlvbnNDb250cm9sIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmdldEdsb2JhbEFjdGlvbnMoKVxuICAgICAgICBjb25zdCBuYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFzeW5jIChpdGVtKSA9PiBpdGVtLmdldFRpdGxlKCkpKVxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmZpbmRJbmRleCgodmFsdWUpID0+IHZhbHVlLmluZGV4T2YobmFtZSkgPiAtMSlcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25zW2luZGV4XVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG59XG4iXX0=