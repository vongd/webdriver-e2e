var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Editor } from './Editor.js';
import { EditorView } from '../index.js';
import { PageDecorator, BasePage, sleep } from '../utils.js';
import { SettingsEditor as SettingsEditorLocators } from '../../locators/1.73.0.js';
/**
 * Page object representing the internal VSCode settings editor
 *
 * @category Editor
 */
let SettingsEditor = class SettingsEditor extends Editor {
    constructor(locators, view) {
        super(locators, view?.elem);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
        this.view = view || new EditorView(this.locatorMap);
    }
    /**
     * Search for a setting with a particular title and category.
     * Returns an appropriate Setting object if the label is found,
     * undefined otherwise.
     *
     * If your setting has nested categories (i.e `example.general.test`),
     * pass in each category as a separate string.
     *
     * @param title title of the setting
     * @param categories category of the setting
     * @returns Promise resolving to a Setting object if found, undefined otherwise
     */
    async findSetting(title, ...categories) {
        const category = categories.join(' â€º ');
        const searchBox = await this.elem.$(this.locatorMap.Editor.inputArea);
        await searchBox.setValue(`${category}: ${title}`);
        const count = await this.itemCount$;
        let textCount = await count.getText();
        await browser.waitUntil(async () => {
            await sleep(1500);
            const text = await count.getText();
            if (text !== textCount) {
                textCount = text;
                return false;
            }
            return true;
        });
        let setting;
        const items = await this.itemRow$$;
        for (const item of items) {
            try {
                return await (await this.createSetting(item, title, category)).wait();
            }
            catch (err) {
                // ignore
            }
        }
        return setting;
    }
    /**
     * Switch between settings perspectives
     * Works only if your vscode instance has both user and workspace settings available
     *
     * @param perspective User or Workspace
     * @returns Promise that resolves when the appropriate button is clicked
     */
    async switchToPerspective(perspective) {
        await this.header$
            .$(this.locators.tabs)
            .$(this.locators.actions)
            .$(this.locators.action(perspective))
            .click();
    }
    /**
     * Context menu is disabled in this editor, throw an error
     */
    openContextMenu() {
        throw new Error('Operation not supported');
    }
    async createSetting(element, title, category) {
        if (!await element.$(this.locators.settingConstructor(title, category)).isExisting()) {
            throw new Error('Setting not found');
        }
        // try a combo setting
        if (await element.$(this.locators.comboSetting).isExisting()) {
            return new ComboSetting(this.locatorMap, title, category, this);
        }
        // try text setting
        if (await element.$(this.locators.textSetting).isExisting()) {
            return new TextSetting(this.locatorMap, title, category, this);
        }
        // try checkbox setting
        if (await element.$(this.locators.checkboxSetting).isExisting()) {
            return new CheckboxSetting(this.locatorMap, title, category, this);
        }
        // try link setting
        if (await element.$(this.locators.linkButton).isExisting()) {
            return new LinkSetting(this.locatorMap, title, category, this);
        }
        throw new Error('Setting type not supported');
    }
};
SettingsEditor = __decorate([
    PageDecorator(SettingsEditorLocators)
], SettingsEditor);
export { SettingsEditor };
/**
 * Abstract item representing a Setting with title, description and
 * an input element (combo/textbox/checkbox/link)
 *
 * @category Editor
 */
export class Setting extends BasePage {
    constructor(locators, title, category, settings) {
        super(locators, locators.SettingsEditor.settingConstructor(title, category));
        this.settings = settings;
        this.title = title;
        this.category = category;
    }
    /**
     * Get the category of the setting
     * All settings are labeled as Category: Title
     */
    getCategory() {
        return this.category;
    }
    /**
     * Get description of the setting
     * @returns Promise resolving to setting description
     */
    async getDescription() {
        return this.settingDesctiption$.getText();
    }
    /**
     * Get title of the setting
     */
    getTitle() {
        return this.title;
    }
}
/**
 * Setting with a combo box
 *
 * @category Editor
 */
let ComboSetting = class ComboSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        return this.comboSetting$.getAttribute('title');
    }
    async setValue(value) {
        const rows = await this.getOptions();
        for (let i = 0; i < rows.length; i += 1) {
            if ((await rows[i].getAttribute('class')).indexOf('disabled') < 0) {
                const text = await rows[i].$(this.locators.comboOption).getText();
                if (value === text) {
                    await rows[i].click();
                    return;
                }
            }
        }
    }
    /**
     * Get the labels of all options from the combo
     * @returns Promise resolving to array of string values
     */
    async getValues() {
        const values = [];
        const rows = await this.getOptions();
        for (const row of rows) {
            values.push(await row.$(this.locators.comboOption).getText());
        }
        return values;
    }
    async getOptions() {
        const menu = await this.openCombo();
        return menu.$$(this.locators.itemRow);
    }
    async openCombo() {
        const combo = await this.comboSetting$;
        const workbench = await browser.$(this.locatorMap.Workbench.elem);
        const menus = await workbench.$$(this.locatorMap.ContextMenu.contextView);
        let menu;
        if (menus.length < 1) {
            await combo.click();
            menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
            return menu;
        }
        if (await menus[0].isDisplayed()) {
            await combo.click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
        }
        await combo.click();
        menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
        return menu;
    }
};
ComboSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], ComboSetting);
export { ComboSetting };
/**
 * Setting with a text box input
 *
 * @category Editor
 */
let TextSetting = class TextSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        return this.textSetting$.getAttribute('value');
    }
    async setValue(value) {
        const input = await this.textSetting$;
        await input.setValue(value);
    }
};
TextSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], TextSetting);
export { TextSetting };
/**
 * Setting with a checkbox
 *
 * @category Editor
 */
let CheckboxSetting = class CheckboxSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        const checked = await this.checkboxSetting$.getAttribute(this.locators.checkboxChecked);
        if (checked === 'true') {
            return true;
        }
        return false;
    }
    async setValue(value) {
        if (await this.getValue() !== value) {
            await this.checkboxSetting$.click();
        }
    }
};
CheckboxSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], CheckboxSetting);
export { CheckboxSetting };
/**
 * Setting with no value, with a link to settings.json instead
 *
 * @category Editor
 */
let LinkSetting = class LinkSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        throw new Error('Method getValue is not available for LinkSetting');
    }
    setValue() {
        throw new Error('Method setValue is not available for LinkSetting');
    }
    /**
     * Open the link that leads to the value in settings.json
     * @returns Promise resolving when the link has been clicked
     */
    async openLink() {
        await this.linkButton$.click();
    }
};
LinkSetting = __decorate([
    PageDecorator(SettingsEditorLocators)
], LinkSetting);
export { LinkSetting };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2V0dGluZ3NFZGl0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvZWRpdG9yL1NldHRpbmdzRWRpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBRXBELE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSxhQUFhLENBQUE7QUFFckQsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFvQixLQUFLLEVBQ25FLE1BQU0sYUFBYSxDQUFBO0FBQ3BCLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUduRjs7OztHQUlHO0FBRUksSUFBTSxjQUFjLEdBQXBCLE1BQU0sY0FBZSxTQUFRLE1BQXNCO0lBT3RELFlBQ0ksUUFBMEIsRUFDMUIsSUFBK0I7UUFFL0IsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFWL0I7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7UUFRekMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUUsS0FBYSxFQUFFLEdBQUcsVUFBb0I7UUFDckQsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUN2QyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQW1CLENBQUMsQ0FBQTtRQUMvRSxNQUFNLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FB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QkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtTQUN0QztJQUNMLENBQUM7Q0FDSixDQUFBO0FBbkJZLGVBQWU7SUFEM0IsYUFBYSxDQUFDLHNCQUFzQixDQUFDO0dBQ3pCLGVBQWUsQ0FtQjNCO1NBbkJZLGVBQWU7QUFzQjVCOzs7O0dBSUc7QUFFSSxJQUFNLFdBQVcsR0FBakIsTUFBTSxXQUFZLFNBQVEsT0FBTztJQUFqQzs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxnQkFBeUIsQ0FBQTtJQWlCakQsQ0FBQztJQWZHLFFBQVE7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUE7SUFDdkUsQ0FBQztJQUVELFFBQVE7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUE7SUFDdkUsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxRQUFRO1FBQ1YsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2xDLENBQUM7Q0FDSixDQUFBO0FBckJZLFdBQVc7SUFEdkIsYUFBYSxDQUFDLHNCQUFzQixDQUFDO0dBQ3pCLFdBQVcsQ0FxQnZCO1NBckJZLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IsIEVkaXRvckxvY2F0b3JzIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBDb250ZXh0TWVudSB9IGZyb20gJy4uL21lbnUvQ29udGV4dE1lbnUuanMnXG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBFZGl0b3JHcm91cCB9IGZyb20gJy4uL2luZGV4LmpzJ1xuXG5pbXBvcnQge1xuICAgIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSwgVlNDb2RlTG9jYXRvck1hcCwgc2xlZXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBTZXR0aW5nc0VkaXRvciBhcyBTZXR0aW5nc0VkaXRvckxvY2F0b3JzIH0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzRWRpdG9yIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8RWRpdG9yTG9jYXRvcnM+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW50ZXJuYWwgVlNDb2RlIHNldHRpbmdzIGVkaXRvclxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2V0dGluZ3NFZGl0b3JMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBTZXR0aW5nc0VkaXRvciBleHRlbmRzIEVkaXRvcjxFZGl0b3JMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2V0dGluZ3NFZGl0b3InIGFzIGNvbnN0XG4gICAgcHVibGljIHZpZXc6IEVkaXRvclZpZXcgfCBFZGl0b3JHcm91cFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgdmlldz86IEVkaXRvclZpZXcgfCBFZGl0b3JHcm91cFxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgdmlldz8uZWxlbSlcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldyB8fCBuZXcgRWRpdG9yVmlldyh0aGlzLmxvY2F0b3JNYXApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBhIHNldHRpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdGl0bGUgYW5kIGNhdGVnb3J5LlxuICAgICAqIFJldHVybnMgYW4gYXBwcm9wcmlhdGUgU2V0dGluZyBvYmplY3QgaWYgdGhlIGxhYmVsIGlzIGZvdW5kLFxuICAgICAqIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3VyIHNldHRpbmcgaGFzIG5lc3RlZCBjYXRlZ29yaWVzIChpLmUgYGV4YW1wbGUuZ2VuZXJhbC50ZXN0YCksXG4gICAgICogcGFzcyBpbiBlYWNoIGNhdGVnb3J5IGFzIGEgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSBzZXR0aW5nXG4gICAgICogQHBhcmFtIGNhdGVnb3JpZXMgY2F0ZWdvcnkgb2YgdGhlIHNldHRpbmdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIFNldHRpbmcgb2JqZWN0IGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgZmluZFNldHRpbmcgKHRpdGxlOiBzdHJpbmcsIC4uLmNhdGVnb3JpZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxTZXR0aW5nPiB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gY2F0ZWdvcmllcy5qb2luKCcg4oC6ICcpXG4gICAgICAgIGNvbnN0IHNlYXJjaEJveCA9IGF3YWl0IHRoaXMuZWxlbS4kKHRoaXMubG9jYXRvck1hcC5FZGl0b3IuaW5wdXRBcmVhIGFzIHN0cmluZylcbiAgICAgICAgYXdhaXQgc2VhcmNoQm94LnNldFZhbHVlKGAke2NhdGVnb3J5fTogJHt0aXRsZX1gKVxuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5pdGVtQ291bnQkXG4gICAgICAgIGxldCB0ZXh0Q291bnQgPSBhd2FpdCBjb3VudC5nZXRUZXh0KClcblxuICAgICAgICBhd2FpdCBicm93c2VyLndhaXRVbnRpbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCgxNTAwKVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGNvdW50LmdldFRleHQoKVxuICAgICAgICAgICAgaWYgKHRleHQgIT09IHRleHRDb3VudCkge1xuICAgICAgICAgICAgICAgIHRleHRDb3VudCA9IHRleHRcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IHNldHRpbmchOiBTZXR0aW5nXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5pdGVtUm93JCRcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAoYXdhaXQgdGhpcy5jcmVhdGVTZXR0aW5nKGl0ZW0sIHRpdGxlLCBjYXRlZ29yeSkpLndhaXQoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggYmV0d2VlbiBzZXR0aW5ncyBwZXJzcGVjdGl2ZXNcbiAgICAgKiBXb3JrcyBvbmx5IGlmIHlvdXIgdnNjb2RlIGluc3RhbmNlIGhhcyBib3RoIHVzZXIgYW5kIHdvcmtzcGFjZSBzZXR0aW5ncyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJzcGVjdGl2ZSBVc2VyIG9yIFdvcmtzcGFjZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhcHByb3ByaWF0ZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGFzeW5jIHN3aXRjaFRvUGVyc3BlY3RpdmUgKHBlcnNwZWN0aXZlOiAnVXNlcicgfCAnV29ya3NwYWNlJyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmhlYWRlciRcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMudGFicylcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMuYWN0aW9ucylcbiAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMuYWN0aW9uKHBlcnNwZWN0aXZlKSlcbiAgICAgICAgICAgIC5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBtZW51IGlzIGRpc2FibGVkIGluIHRoaXMgZWRpdG9yLCB0aHJvdyBhbiBlcnJvclxuICAgICAqL1xuICAgIG9wZW5Db250ZXh0TWVudSAoKTogUHJvbWlzZTxDb250ZXh0TWVudT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVNldHRpbmcgKGVsZW1lbnQ6IFdlYmRyaXZlcklPLkVsZW1lbnQsIHRpdGxlOiBzdHJpbmcsIGNhdGVnb3J5OiBzdHJpbmcpOiBQcm9taXNlPFNldHRpbmc+IHtcbiAgICAgICAgaWYgKCFhd2FpdCBlbGVtZW50LiQodGhpcy5sb2NhdG9ycy5zZXR0aW5nQ29uc3RydWN0b3IodGl0bGUsIGNhdGVnb3J5KSkuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldHRpbmcgbm90IGZvdW5kJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSBhIGNvbWJvIHNldHRpbmdcbiAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuJCh0aGlzLmxvY2F0b3JzLmNvbWJvU2V0dGluZykuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbWJvU2V0dGluZyh0aGlzLmxvY2F0b3JNYXAsIHRpdGxlLCBjYXRlZ29yeSwgdGhpcylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0ZXh0IHNldHRpbmdcbiAgICAgICAgaWYgKGF3YWl0IGVsZW1lbnQuJCh0aGlzLmxvY2F0b3JzLnRleHRTZXR0aW5nKS5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFNldHRpbmcodGhpcy5sb2NhdG9yTWFwLCB0aXRsZSwgY2F0ZWdvcnksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgY2hlY2tib3ggc2V0dGluZ1xuICAgICAgICBpZiAoYXdhaXQgZWxlbWVudC4kKHRoaXMubG9jYXRvcnMuY2hlY2tib3hTZXR0aW5nKS5pc0V4aXN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hTZXR0aW5nKHRoaXMubG9jYXRvck1hcCwgdGl0bGUsIGNhdGVnb3J5LCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IGxpbmsgc2V0dGluZ1xuICAgICAgICBpZiAoYXdhaXQgZWxlbWVudC4kKHRoaXMubG9jYXRvcnMubGlua0J1dHRvbikuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmtTZXR0aW5nKHRoaXMubG9jYXRvck1hcCwgdGl0bGUsIGNhdGVnb3J5LCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXR0aW5nIHR5cGUgbm90IHN1cHBvcnRlZCcpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycz4ge31cbi8qKlxuICogQWJzdHJhY3QgaXRlbSByZXByZXNlbnRpbmcgYSBTZXR0aW5nIHdpdGggdGl0bGUsIGRlc2NyaXB0aW9uIGFuZFxuICogYW4gaW5wdXQgZWxlbWVudCAoY29tYm8vdGV4dGJveC9jaGVja2JveC9saW5rKVxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNldHRpbmcgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycz4ge1xuICAgIHByaXZhdGUgdGl0bGU6IHN0cmluZ1xuICAgIHByaXZhdGUgY2F0ZWdvcnk6IHN0cmluZ1xuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgICAgICAgcHVibGljIHNldHRpbmdzOiBTZXR0aW5nc0VkaXRvclxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgKGxvY2F0b3JzLlNldHRpbmdzRWRpdG9yLnNldHRpbmdDb25zdHJ1Y3RvciBhcyBGdW5jdGlvbikodGl0bGUsIGNhdGVnb3J5KSBhcyBzdHJpbmcpXG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nIGJhc2VkIG9uIGl0cyBpbnB1dCB0eXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNldHRpbmdcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRWYWx1ZSAoKTogUHJvbWlzZTxzdHJpbmcgfCBib29sZWFuPlxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZyBiYXNlZCBvbiBpdHMgaW5wdXQgdHlwZVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGJvb2xlYW4gZm9yIGNoZWNrYm94ZXMsIHN0cmluZyBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRWYWx1ZSAodmFsdWU6IHN0cmluZyB8IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhdGVnb3J5IG9mIHRoZSBzZXR0aW5nXG4gICAgICogQWxsIHNldHRpbmdzIGFyZSBsYWJlbGVkIGFzIENhdGVnb3J5OiBUaXRsZVxuICAgICAqL1xuICAgIGdldENhdGVnb3J5ICgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yeVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkZXNjcmlwdGlvbiBvZiB0aGUgc2V0dGluZ1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHNldHRpbmcgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXNjcmlwdGlvbiAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ0Rlc2N0aXB0aW9uJC5nZXRUZXh0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGl0bGUgb2YgdGhlIHNldHRpbmdcbiAgICAgKi9cbiAgICBnZXRUaXRsZSAoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGVcbiAgICB9XG59XG5cbi8qKlxuICogU2V0dGluZyB3aXRoIGEgY29tYm8gYm94XG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihTZXR0aW5nc0VkaXRvckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIENvbWJvU2V0dGluZyBleHRlbmRzIFNldHRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2V0dGluZ3NFZGl0b3InIGFzIGNvbnN0XG5cbiAgICBnZXRWYWx1ZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tYm9TZXR0aW5nJC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICB9XG5cbiAgICBhc3luYyBzZXRWYWx1ZSAodmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCByb3dzID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKGF3YWl0IHJvd3NbaV0uZ2V0QXR0cmlidXRlKCdjbGFzcycpKS5pbmRleE9mKCdkaXNhYmxlZCcpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByb3dzW2ldLiQodGhpcy5sb2NhdG9ycy5jb21ib09wdGlvbikuZ2V0VGV4dCgpXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJvd3NbaV0uY2xpY2soKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhYmVscyBvZiBhbGwgb3B0aW9ucyBmcm9tIHRoZSBjb21ib1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIHN0cmluZyB2YWx1ZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRWYWx1ZXMgKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW11cbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuZ2V0T3B0aW9ucygpXG5cbiAgICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goYXdhaXQgcm93LiQodGhpcy5sb2NhdG9ycy5jb21ib09wdGlvbikuZ2V0VGV4dCgpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldE9wdGlvbnMgKCkge1xuICAgICAgICBjb25zdCBtZW51ID0gYXdhaXQgdGhpcy5vcGVuQ29tYm8oKVxuICAgICAgICByZXR1cm4gbWVudS4kJCh0aGlzLmxvY2F0b3JzLml0ZW1Sb3cpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBvcGVuQ29tYm8gKCkge1xuICAgICAgICBjb25zdCBjb21ibyA9IGF3YWl0IHRoaXMuY29tYm9TZXR0aW5nJFxuICAgICAgICBjb25zdCB3b3JrYmVuY2ggPSBhd2FpdCBicm93c2VyLiQodGhpcy5sb2NhdG9yTWFwLldvcmtiZW5jaC5lbGVtIGFzIHN0cmluZylcbiAgICAgICAgY29uc3QgbWVudXMgPSBhd2FpdCB3b3JrYmVuY2guJCQodGhpcy5sb2NhdG9yTWFwLkNvbnRleHRNZW51LmNvbnRleHRWaWV3IGFzIHN0cmluZylcbiAgICAgICAgbGV0IG1lbnUhOiBXZWJkcml2ZXJJTy5FbGVtZW50XG5cbiAgICAgICAgaWYgKG1lbnVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbWJvLmNsaWNrKClcbiAgICAgICAgICAgIG1lbnUgPSBhd2FpdCB3b3JrYmVuY2guJCh0aGlzLmxvY2F0b3JNYXAuQ29udGV4dE1lbnUuY29udGV4dFZpZXcgYXMgc3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIG1lbnVcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXdhaXQgbWVudXNbMF0uaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgY29tYm8uY2xpY2soKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHdkaW8vbm8tcGF1c2VcbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXIucGF1c2UoMjAwKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbWJvLmNsaWNrKClcbiAgICAgICAgbWVudSA9IGF3YWl0IHdvcmtiZW5jaC4kKHRoaXMubG9jYXRvck1hcC5Db250ZXh0TWVudS5jb250ZXh0VmlldyBhcyBzdHJpbmcpXG4gICAgICAgIHJldHVybiBtZW51XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTZXR0aW5nIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNldHRpbmdzRWRpdG9yTG9jYXRvcnM+IHt9XG4vKipcbiAqIFNldHRpbmcgd2l0aCBhIHRleHQgYm94IGlucHV0XG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihTZXR0aW5nc0VkaXRvckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFRleHRTZXR0aW5nIGV4dGVuZHMgU2V0dGluZyB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTZXR0aW5nc0VkaXRvcicgYXMgY29uc3RcblxuICAgIGFzeW5jIGdldFZhbHVlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0U2V0dGluZyQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0VmFsdWUgKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhd2FpdCB0aGlzLnRleHRTZXR0aW5nJFxuICAgICAgICBhd2FpdCBpbnB1dC5zZXRWYWx1ZSh2YWx1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFNldHRpbmcgZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgU2V0dGluZ3NFZGl0b3JMb2NhdG9ycz4ge31cbi8qKlxuICogU2V0dGluZyB3aXRoIGEgY2hlY2tib3hcbiAqXG4gKiBAY2F0ZWdvcnkgRWRpdG9yXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNldHRpbmdzRWRpdG9yTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hTZXR0aW5nIGV4dGVuZHMgU2V0dGluZyB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTZXR0aW5nc0VkaXRvcicgYXMgY29uc3RcblxuICAgIGFzeW5jIGdldFZhbHVlICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IGF3YWl0IHRoaXMuY2hlY2tib3hTZXR0aW5nJC5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhdG9ycy5jaGVja2JveENoZWNrZWQpXG4gICAgICAgIGlmIChjaGVja2VkID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0VmFsdWUgKHZhbHVlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmdldFZhbHVlKCkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrYm94U2V0dGluZyQuY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtTZXR0aW5nIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNldHRpbmdzRWRpdG9yTG9jYXRvcnM+IHt9XG4vKipcbiAqIFNldHRpbmcgd2l0aCBubyB2YWx1ZSwgd2l0aCBhIGxpbmsgdG8gc2V0dGluZ3MuanNvbiBpbnN0ZWFkXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihTZXR0aW5nc0VkaXRvckxvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIExpbmtTZXR0aW5nIGV4dGVuZHMgU2V0dGluZyB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTZXR0aW5nc0VkaXRvcicgYXMgY29uc3RcblxuICAgIGdldFZhbHVlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBnZXRWYWx1ZSBpcyBub3QgYXZhaWxhYmxlIGZvciBMaW5rU2V0dGluZycpXG4gICAgfVxuXG4gICAgc2V0VmFsdWUgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBzZXRWYWx1ZSBpcyBub3QgYXZhaWxhYmxlIGZvciBMaW5rU2V0dGluZycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgbGluayB0aGF0IGxlYWRzIHRvIHRoZSB2YWx1ZSBpbiBzZXR0aW5ncy5qc29uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgbGluayBoYXMgYmVlbiBjbGlja2VkXG4gICAgICovXG4gICAgYXN5bmMgb3BlbkxpbmsgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmxpbmtCdXR0b24kLmNsaWNrKClcbiAgICB9XG59XG4iXX0=