{"version":3,"file":"utils.js","sourceRoot":"","sources":["../lib/utils.ts"],"names":[],"mappings":";;;;;AAEA,2CAAqC;AACrC,+CAA6C;AAC7C,4DAAmC;AAEnC,MAAqB,KAAK;IAQf,eAAe,CAAG,QAAgB;QACrC,MAAM,OAAO,GAAG,kBAAQ,CAAC,QAAQ,CAAC,CAAC;QACnC,OAAS,EAAgB;aACpB,MAAM,CAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAE;aAChE,GAAG,CAAE,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAE,MAAM,EAAE,EAAE,CAAE,CAAE,CAAC;IACzD,CAAC;IASM,gBAAgB,CAAG,UAAiC;QACvD,IAAK,UAAU,CAAC,KAAK,KAAK,kBAAM,EAAG;YAC/B,OAAO;gBACH,aAAa,EAAE,IAAA,oBAAS,EAAE,UAAU,CAAC,KAAK,CAAC,KAAK,CAAE;aACrD,CAAC;SACL;QAED,OAAO,EAAE,CAAC;IACd,CAAC;IAWM,aAAa,CAAG,KAAa,EAAE,QAAgB;QAClD,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAE,QAAQ,CAAE,CAAC;QACtD,OAAO,KAAK,CAAC,IAAI,CAAE,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAE,IAAI,CAAC,OAAO,CAAE,CAAE,CAAC;IACvE,CAAC;IAWM,iBAAiB,CAAG,KAAa,EAAE,QAAgB;QACtD,MAAM,YAAY,GAAG,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,eAAe,CAAE,QAAQ,CAAE,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAE,CAAC;QACxF,MAAM,mBAAmB,GAAG,YAAY,CAAC,GAAG,CAAE,CAAE,OAAe,EAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAE,qBAAqB,EAAE,MAAM,CAAE,CAAE,CAAC;QACxH,MAAM,KAAK,GAAG,IAAI,MAAM,CAAE,KAAK,mBAAmB,CAAC,IAAI,CAAE,GAAG,CAAE,MAAM,CAAE,CAAC;QACvE,OAAO,CAAE,KAAK,CAAC,IAAI,CAAE,KAAK,CAAE,IAAI,EAAE,CAAE,CAAC,GAAG,EAAY,CAAC;IACzD,CAAC;CACJ;AA7DD,wBA6DC","sourcesContent":["import { ErrorMessage, Step } from './models';\nimport { HookStats, TestStats } from '@wdio/reporter';\nimport { FAILED } from './constants';\nimport { dialects } from '@cucumber/gherkin';\nimport stripAnsi from 'strip-ansi';\n\nexport default class Utils {\n    /**\n     * Return the list of step keywords in the specified language\n     *\n     * @param language {string}\n     *\n     * @return {string[]}\n     */\n    public getStepKeywords ( language: string ): string[] {\n        const dialect = dialects[language];\n        return ( [] as string[] )\n            .concat( dialect.given, dialect.when, dialect.then, dialect.and )\n            .map( keyword => keyword.replace( /\\s*$/, '' ) );\n    }\n\n    /**\n     * Add a failed message\n     *\n     * @param {object}  testObject\n     *\n     * @return {object}\n     */\n    public getFailedMessage ( testObject: TestStats | HookStats ): ErrorMessage {\n        if ( testObject.state === FAILED ) {\n            return {\n                error_message: stripAnsi( testObject.error.stack ),\n            };\n        }\n\n        return {};\n    }\n\n    /**\n     * Check if the steps contain valid steps\n     *\n     * @param {array} steps\n     *\n     * @param {string} language\n     *\n     * @return {boolean}\n     */\n    public containsSteps ( steps: Step[], language: string ): boolean {\n        const stepKeywords = this.getStepKeywords( language );\n        return steps.some( step => stepKeywords.includes( step.keyword ) );\n    }\n\n    /**\n     * Returns the first word in case it's a keyword in the specified language\n     *\n     * @param {array} title\n     *\n     * @param {string} language\n     *\n     * @return {string|undefined}\n     */\n    public keywordStartsWith ( title: string, language: string ): string | undefined {\n        const stepKeywords = [].concat( this.getStepKeywords( language ), ['After', 'Before'] );\n        const escapedStepKeywords = stepKeywords.map( ( keyword: string ) => keyword.replace( /[.*+?^${}()|[\\]\\\\]/g, '\\\\$&' ) );\n        const regex = new RegExp( `^(${escapedStepKeywords.join( '|' )})\\\\s` );\n        return ( regex.exec( title ) || [] ).pop() as string;\n    }\n}\n"]}