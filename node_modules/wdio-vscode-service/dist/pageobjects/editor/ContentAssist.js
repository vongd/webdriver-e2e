var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Key } from 'webdriverio';
import { Menu, MenuItem } from '../index.js';
import { PageDecorator, sleep } from '../utils.js';
import { ContentAssist as ContentAssistLocators } from '../../locators/1.73.0.js';
/**
 * Page object representing the content assistant
 *
 * @category Editor
 */
let ContentAssist = class ContentAssist extends Menu {
    constructor(locators, parent) {
        super(locators);
        /**
         * @private
         */
        this.locatorKey = 'ContentAssist';
        this.setParentElement(parent.elem);
    }
    /**
     * Get content assist item by name/text, scroll through the list
     * until the item is found, or the end is reached
     *
     * @param name name/text to search by
     * @returns Promise resolving to ContentAssistItem object if found, undefined otherwise
     */
    async getItem(name) {
        let lastItem = false;
        let firstItem = await this.firstItem$$;
        while (firstItem.length < 1) {
            await browser.action('key')
                .down(Key.PageUp).up(Key.PageUp)
                .perform();
            firstItem = await this.firstItem$$;
        }
        while (!lastItem) {
            const items = await this.getItems();
            for (const item of items) {
                if (await item.getLabel() === name) {
                    return item;
                }
                lastItem = lastItem || (await item.elem.getAttribute('data-last-element')) === 'true';
            }
            if (!lastItem) {
                await browser.action('key')
                    .down(Key.PageDown).up(Key.PageDown)
                    .perform();
                await sleep(100);
            }
        }
        return undefined;
    }
    /**
     * Get all visible content assist items
     * @returns Promise resolving to array of ContentAssistItem objects
     */
    async getItems() {
        await browser.waitUntil(() => this.isLoaded());
        const elements = await this.elem
            .$(this.locators.itemRows)
            .$$(this.locators.itemRow);
        const items = [];
        for (const item of elements) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            items.push(await new ContentAssistItem(this.locatorMap, item, this).wait());
        }
        return items;
    }
    /**
     * Find if the content assist is still loading the suggestions
     * @returns promise that resolves to true when suggestions are done loading,
     * to false otherwise
     */
    async isLoaded() {
        const message = await this.message$;
        if (await message.isDisplayed()) {
            if ((await message.getText()).startsWith('No suggestions')) {
                return true;
            }
            return false;
        }
        return true;
    }
};
ContentAssist = __decorate([
    PageDecorator(ContentAssistLocators)
], ContentAssist);
export { ContentAssist };
/**
 * Page object for a content assist item
 *
 * @category Editor
 */
let ContentAssistItem = class ContentAssistItem extends MenuItem {
    constructor(locators, item, contentAssist) {
        super(locators, item);
        /**
         * @private
         */
        this.locatorKey = 'ContentAssist';
        this.label = '';
        this.parentMenu = contentAssist;
    }
    async getLabel() {
        const labelDiv = await this.itemLabel$;
        return labelDiv.getText();
    }
};
ContentAssistItem = __decorate([
    PageDecorator(ContentAssistLocators)
], ContentAssistItem);
export { ContentAssistItem };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGVudEFzc2lzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9lZGl0b3IvQ29udGVudEFzc2lzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsR0FBRyxFQUEyQixNQUFNLGFBQWEsQ0FBQTtBQUUxRCxPQUFPLEVBQ1MsSUFBSSxFQUFFLFFBQVEsRUFDN0IsTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUNILGFBQWEsRUFBb0MsS0FBSyxFQUN6RCxNQUFNLGFBQWEsQ0FBQTtBQUNwQixPQUFPLEVBQUUsYUFBYSxJQUFJLHFCQUFxQixFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFHakY7Ozs7R0FJRztBQUVJLElBQU0sYUFBYSxHQUFuQixNQUFNLGFBQWMsU0FBUSxJQUFrQztJQU1qRSxZQUNJLFFBQTBCLEVBQzFCLE1BQXFDO1FBRXJDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQVRuQjs7V0FFRztRQUNJLGVBQVUsR0FBRyxlQUF3QixDQUFBO1FBT3hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxPQUFPLENBQUUsSUFBWTtRQUN2QixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUE7UUFDcEIsSUFBSSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFBO1FBQ3RDLE9BQU8sU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDekIsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztpQkFDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztpQkFDL0IsT0FBTyxFQUFFLENBQUE7WUFDZCxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxD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QUFpQixDQXFCN0I7U0FyQlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgS2V5LCBDaGFpbmFibGVQcm9taXNlRWxlbWVudCB9IGZyb20gJ3dlYmRyaXZlcmlvJ1xuXG5pbXBvcnQge1xuICAgIFRleHRFZGl0b3IsIE1lbnUsIE1lbnVJdGVtLCBEZWJ1Z0NvbnNvbGVWaWV3XG59IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgVlNDb2RlTG9jYXRvck1hcCwgc2xlZXBcbn0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBDb250ZW50QXNzaXN0IGFzIENvbnRlbnRBc3Npc3RMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50QXNzaXN0IGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIENvbnRlbnRBc3Npc3RMb2NhdG9ycz4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGFzc2lzdGFudFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoQ29udGVudEFzc2lzdExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIENvbnRlbnRBc3Npc3QgZXh0ZW5kcyBNZW51PHR5cGVvZiBDb250ZW50QXNzaXN0TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0NvbnRlbnRBc3Npc3QnIGFzIGNvbnN0XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIGxvY2F0b3JzOiBWU0NvZGVMb2NhdG9yTWFwLFxuICAgICAgICBwYXJlbnQ6IFRleHRFZGl0b3IgfCBEZWJ1Z0NvbnNvbGVWaWV3XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzKVxuICAgICAgICB0aGlzLnNldFBhcmVudEVsZW1lbnQocGFyZW50LmVsZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbnRlbnQgYXNzaXN0IGl0ZW0gYnkgbmFtZS90ZXh0LCBzY3JvbGwgdGhyb3VnaCB0aGUgbGlzdFxuICAgICAqIHVudGlsIHRoZSBpdGVtIGlzIGZvdW5kLCBvciB0aGUgZW5kIGlzIHJlYWNoZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUvdGV4dCB0byBzZWFyY2ggYnlcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBDb250ZW50QXNzaXN0SXRlbSBvYmplY3QgaWYgZm91bmQsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJdGVtIChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPENvbnRlbnRBc3Npc3RJdGVtIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGxldCBsYXN0SXRlbSA9IGZhbHNlXG4gICAgICAgIGxldCBmaXJzdEl0ZW0gPSBhd2FpdCB0aGlzLmZpcnN0SXRlbSQkXG4gICAgICAgIHdoaWxlIChmaXJzdEl0ZW0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci5hY3Rpb24oJ2tleScpXG4gICAgICAgICAgICAgICAgLmRvd24oS2V5LlBhZ2VVcCkudXAoS2V5LlBhZ2VVcClcbiAgICAgICAgICAgICAgICAucGVyZm9ybSgpXG4gICAgICAgICAgICBmaXJzdEl0ZW0gPSBhd2FpdCB0aGlzLmZpcnN0SXRlbSQkXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoIWxhc3RJdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuZ2V0SXRlbXMoKVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgaXRlbS5nZXRMYWJlbCgpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RJdGVtID0gbGFzdEl0ZW0gfHwgKGF3YWl0IGl0ZW0uZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGFzdC1lbGVtZW50JykpID09PSAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGFzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBicm93c2VyLmFjdGlvbigna2V5JylcbiAgICAgICAgICAgICAgICAgICAgLmRvd24oS2V5LlBhZ2VEb3duKS51cChLZXkuUGFnZURvd24pXG4gICAgICAgICAgICAgICAgICAgIC5wZXJmb3JtKClcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCgxMDApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB2aXNpYmxlIGNvbnRlbnQgYXNzaXN0IGl0ZW1zXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgQ29udGVudEFzc2lzdEl0ZW0gb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEl0ZW1zICgpOiBQcm9taXNlPENvbnRlbnRBc3Npc3RJdGVtW10+IHtcbiAgICAgICAgYXdhaXQgYnJvd3Nlci53YWl0VW50aWwoKCkgPT4gdGhpcy5pc0xvYWRlZCgpKVxuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdGhpcy5lbGVtXG4gICAgICAgICAgICAuJCh0aGlzLmxvY2F0b3JzLml0ZW1Sb3dzKVxuICAgICAgICAgICAgLiQkKHRoaXMubG9jYXRvcnMuaXRlbVJvdylcbiAgICAgICAgY29uc3QgaXRlbXM6IENvbnRlbnRBc3Npc3RJdGVtW10gPSBbXVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYXdhaXQgbmV3IENvbnRlbnRBc3Npc3RJdGVtKHRoaXMubG9jYXRvck1hcCwgaXRlbSBhcyBhbnksIHRoaXMpLndhaXQoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGlmIHRoZSBjb250ZW50IGFzc2lzdCBpcyBzdGlsbCBsb2FkaW5nIHRoZSBzdWdnZXN0aW9uc1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIHdoZW4gc3VnZ2VzdGlvbnMgYXJlIGRvbmUgbG9hZGluZyxcbiAgICAgKiB0byBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBpc0xvYWRlZCAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm1lc3NhZ2UkXG4gICAgICAgIGlmIChhd2FpdCBtZXNzYWdlLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgbWVzc2FnZS5nZXRUZXh0KCkpLnN0YXJ0c1dpdGgoJ05vIHN1Z2dlc3Rpb25zJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEFzc2lzdEl0ZW0gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgQ29udGVudEFzc2lzdExvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgYSBjb250ZW50IGFzc2lzdCBpdGVtXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihDb250ZW50QXNzaXN0TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgQ29udGVudEFzc2lzdEl0ZW0gZXh0ZW5kcyBNZW51SXRlbTx0eXBlb2YgQ29udGVudEFzc2lzdExvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdDb250ZW50QXNzaXN0JyBhcyBjb25zdFxuICAgIHB1YmxpYyBwYXJlbnRNZW51OiBDb250ZW50QXNzaXN0XG4gICAgcHVibGljIGxhYmVsID0gJydcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGl0ZW06IHN0cmluZyB8IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBjb250ZW50QXNzaXN0OiBDb250ZW50QXNzaXN0XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBpdGVtKVxuICAgICAgICB0aGlzLnBhcmVudE1lbnUgPSBjb250ZW50QXNzaXN0XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0TGFiZWwgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGxhYmVsRGl2ID0gYXdhaXQgdGhpcy5pdGVtTGFiZWwkXG4gICAgICAgIHJldHVybiBsYWJlbERpdi5nZXRUZXh0KClcbiAgICB9XG59XG4iXX0=