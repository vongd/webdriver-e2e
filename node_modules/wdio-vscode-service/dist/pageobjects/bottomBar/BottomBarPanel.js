var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { DebugConsoleView, OutputView, TerminalView, ProblemsView, EditorView, TitleBar, StatusBar } from '../index.js';
import { BasePage, PageDecorator } from '../utils.js';
import { BottomBarPanel as BottomBarPanelLocators } from '../../locators/1.73.0.js';
/**
 * Page object for the bottom view panel
 *
 * ```ts
 * const bottomBar = workbench.getBottomBar()
 * await bottomBar.toggle(true)
 * ```
 *
 * @category BottomBar
 */
let BottomBarPanel = class BottomBarPanel extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'BottomBarPanel';
    }
    /**
     * Open/Close the bottom bar panel
     * @param open true to open. false to close
     * @returns Promise resolving when the view visibility is toggled
     */
    async toggle(open) {
        try {
            const tab = await new EditorView(this.locatorMap).getActiveTab();
            await tab?.elem.click();
        }
        catch (err) {
            // ignore and move on
        }
        const height = await this.elem.getSize('height');
        if ((open && height === 0) || (!open && height > 0)) {
            const statusBar = new StatusBar(this.locatorMap);
            await statusBar.problems$.click();
            if (open) {
                await this.wait();
                return;
            }
            /**
             * we might have to click again if we were on a different tab
             * than the problems tab
             */
            if (await this.elem.isDisplayed()) {
                await statusBar.problems$.click();
            }
            await this.elem.waitForDisplayed({ reverse: true });
        }
    }
    /**
     * Open the Problems view in the bottom panel
     * @returns Promise resolving to a ProblemsView object
     */
    async openProblemsView() {
        await this.openTab(this.locators.problemsTab);
        return new ProblemsView(this.locatorMap, this).wait();
    }
    /**
     * Open the Output view in the bottom panel
     * @returns Promise resolving to OutputView object
     */
    async openOutputView() {
        await this.openTab(this.locators.outputTab);
        return new OutputView(this.locatorMap, this).wait();
    }
    /**
     * Open the Debug Console view in the bottom panel
     * @returns Promise resolving to DebugConsoleView object
     */
    async openDebugConsoleView() {
        await this.openTab(this.locators.debugTab);
        return new DebugConsoleView(this.locatorMap, this).wait();
    }
    /**
     * Open the Terminal view in the bottom panel
     * @returns Promise resolving to TerminalView object
     */
    async openTerminalView() {
        await this.openTab(this.locators.terminalTab);
        return new TerminalView(this.locatorMap, this).wait();
    }
    /**
     * Maximize the the bottom panel if not maximized
     * @returns Promise resolving when the maximize button is pressed
     */
    async maximize() {
        await this.resize(this.locators.maximize);
    }
    /**
     * Restore the the bottom panel if maximized
     * @returns Promise resolving when the restore button is pressed
     */
    async restore() {
        await this.resize(this.locators.restore);
    }
    async openTab(title) {
        await this.toggle(true);
        const tabContainer = await this.tabContainer$;
        try {
            const tabs = await tabContainer.$$(this.locators.tab(title));
            if (tabs.length > 0) {
                await tabs[0].click();
            }
            else {
                const label = await tabContainer.$(`.//a[starts-with(@aria-label, '${title}')]`);
                await label.click();
            }
        }
        catch (err) {
            await new TitleBar(this.locatorMap).select('View', title);
        }
    }
    async resize(label) {
        await this.toggle(true);
        let action;
        try {
            action = await this.elem
                .$(this.locators.globalActions)
                .$(this.locators.action(label));
        }
        catch (err) {
            // the panel is already maximized
        }
        if (action) {
            await action.click();
        }
    }
};
BottomBarPanel = __decorate([
    PageDecorator(BottomBarPanelLocators)
], BottomBarPanel);
export { BottomBarPanel };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm90dG9tQmFyUGFuZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvYm90dG9tQmFyL0JvdHRvbUJhclBhbmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFDSCxnQkFBZ0IsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUM5RSxTQUFTLEVBQ1osTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQWtCLE1BQU0sYUFBYSxDQUFBO0FBQ3JFLE9BQU8sRUFBRSxjQUFjLElBQUksc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUduRjs7Ozs7Ozs7O0dBU0c7QUFFSSxJQUFNLGNBQWMsR0FBcEIsTUFBTSxjQUFlLFNBQVEsUUFBdUM7SUFBcEU7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsZ0JBQXlCLENBQUE7SUF1SGpELENBQUM7SUFySEc7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUUsSUFBYTtRQUN2QixJQUFJO1lBQ0EsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUE7WUFDaEUsTUFBTSxHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO1NBQzFCO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDVixxQkFBcUI7U0FDeEI7UUFDRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBRWhELElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ2pELE1BQU0sU0FBUyxHQUFHLElBQUksU0FB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Q1YsTUFBTSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQTtTQUM1RDtJQUNMLENBQUM7SUFFTyxLQUFLLENBQUMsTUFBTSxDQUFFLEtBQWE7UUFDL0IsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3ZCLElBQUksTUFBNEIsQ0FBQTtRQUNoQyxJQUFJO1lBQ0EsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUk7aUJBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztpQkFDOUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7U0FDdEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLGlDQUFpQztTQUNwQztRQUNELElBQUksTUFBTSxFQUFFO1lBQ1IsTUFBTSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUE7U0FDdkI7SUFDTCxDQUFDO0NBQ0osQ0FBQTtBQTNIWSxjQUFjO0lBRDFCLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQztHQUN6QixjQUFjLENBMkgxQjtTQTNIWSxjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEZWJ1Z0NvbnNvbGVWaWV3LCBPdXRwdXRWaWV3LCBUZXJtaW5hbFZpZXcsIFByb2JsZW1zVmlldywgRWRpdG9yVmlldywgVGl0bGVCYXIsXG4gICAgU3RhdHVzQmFyXG59IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHsgQmFzZVBhZ2UsIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yIH0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBCb3R0b21CYXJQYW5lbCBhcyBCb3R0b21CYXJQYW5lbExvY2F0b3JzIH0gZnJvbSAnLi4vLi4vbG9jYXRvcnMvMS43My4wLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJvdHRvbUJhclBhbmVsIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIEJvdHRvbUJhclBhbmVsTG9jYXRvcnM+IHt9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IGZvciB0aGUgYm90dG9tIHZpZXcgcGFuZWxcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYm90dG9tQmFyID0gd29ya2JlbmNoLmdldEJvdHRvbUJhcigpXG4gKiBhd2FpdCBib3R0b21CYXIudG9nZ2xlKHRydWUpXG4gKiBgYGBcbiAqXG4gKiBAY2F0ZWdvcnkgQm90dG9tQmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKEJvdHRvbUJhclBhbmVsTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgQm90dG9tQmFyUGFuZWwgZXh0ZW5kcyBCYXNlUGFnZTx0eXBlb2YgQm90dG9tQmFyUGFuZWxMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnQm90dG9tQmFyUGFuZWwnIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBPcGVuL0Nsb3NlIHRoZSBib3R0b20gYmFyIHBhbmVsXG4gICAgICogQHBhcmFtIG9wZW4gdHJ1ZSB0byBvcGVuLiBmYWxzZSB0byBjbG9zZVxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHZpZXcgdmlzaWJpbGl0eSBpcyB0b2dnbGVkXG4gICAgICovXG4gICAgYXN5bmMgdG9nZ2xlIChvcGVuOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBhd2FpdCBuZXcgRWRpdG9yVmlldyh0aGlzLmxvY2F0b3JNYXApLmdldEFjdGl2ZVRhYigpXG4gICAgICAgICAgICBhd2FpdCB0YWI/LmVsZW0uY2xpY2soKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBhbmQgbW92ZSBvblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGF3YWl0IHRoaXMuZWxlbS5nZXRTaXplKCdoZWlnaHQnKVxuXG4gICAgICAgIGlmICgob3BlbiAmJiBoZWlnaHQgPT09IDApIHx8ICghb3BlbiAmJiBoZWlnaHQgPiAwKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQmFyID0gbmV3IFN0YXR1c0Jhcih0aGlzLmxvY2F0b3JNYXApXG4gICAgICAgICAgICBhd2FpdCBzdGF0dXNCYXIucHJvYmxlbXMkLmNsaWNrKClcblxuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndhaXQoKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHdlIG1pZ2h0IGhhdmUgdG8gY2xpY2sgYWdhaW4gaWYgd2Ugd2VyZSBvbiBhIGRpZmZlcmVudCB0YWJcbiAgICAgICAgICAgICAqIHRoYW4gdGhlIHByb2JsZW1zIHRhYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5lbGVtLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdGF0dXNCYXIucHJvYmxlbXMkLmNsaWNrKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbGVtLndhaXRGb3JEaXNwbGF5ZWQoeyByZXZlcnNlOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBQcm9ibGVtcyB2aWV3IGluIHRoZSBib3R0b20gcGFuZWxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIFByb2JsZW1zVmlldyBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuUHJvYmxlbXNWaWV3ICgpOiBQcm9taXNlPFByb2JsZW1zVmlldz4ge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW5UYWIodGhpcy5sb2NhdG9ycy5wcm9ibGVtc1RhYilcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ibGVtc1ZpZXcodGhpcy5sb2NhdG9yTWFwLCB0aGlzKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBPdXRwdXQgdmlldyBpbiB0aGUgYm90dG9tIHBhbmVsXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gT3V0cHV0VmlldyBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuT3V0cHV0VmlldyAoKTogUHJvbWlzZTxPdXRwdXRWaWV3PiB7XG4gICAgICAgIGF3YWl0IHRoaXMub3BlblRhYih0aGlzLmxvY2F0b3JzLm91dHB1dFRhYilcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRwdXRWaWV3KHRoaXMubG9jYXRvck1hcCwgdGhpcykud2FpdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgRGVidWcgQ29uc29sZSB2aWV3IGluIHRoZSBib3R0b20gcGFuZWxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBEZWJ1Z0NvbnNvbGVWaWV3IG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5EZWJ1Z0NvbnNvbGVWaWV3ICgpOiBQcm9taXNlPERlYnVnQ29uc29sZVZpZXc+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcGVuVGFiKHRoaXMubG9jYXRvcnMuZGVidWdUYWIpXG4gICAgICAgIHJldHVybiBuZXcgRGVidWdDb25zb2xlVmlldyh0aGlzLmxvY2F0b3JNYXAsIHRoaXMpLndhaXQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIFRlcm1pbmFsIHZpZXcgaW4gdGhlIGJvdHRvbSBwYW5lbFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIFRlcm1pbmFsVmlldyBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuVGVybWluYWxWaWV3ICgpOiBQcm9taXNlPFRlcm1pbmFsVmlldz4ge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW5UYWIodGhpcy5sb2NhdG9ycy50ZXJtaW5hbFRhYilcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hbFZpZXcodGhpcy5sb2NhdG9yTWFwLCB0aGlzKS53YWl0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbWl6ZSB0aGUgdGhlIGJvdHRvbSBwYW5lbCBpZiBub3QgbWF4aW1pemVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgbWF4aW1pemUgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBtYXhpbWl6ZSAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzaXplKHRoaXMubG9jYXRvcnMubWF4aW1pemUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSB0aGUgdGhlIGJvdHRvbSBwYW5lbCBpZiBtYXhpbWl6ZWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSByZXN0b3JlIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgcmVzdG9yZSAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzaXplKHRoaXMubG9jYXRvcnMucmVzdG9yZSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIG9wZW5UYWIgKHRpdGxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50b2dnbGUodHJ1ZSlcbiAgICAgICAgY29uc3QgdGFiQ29udGFpbmVyID0gYXdhaXQgdGhpcy50YWJDb250YWluZXIkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGFiQ29udGFpbmVyLiQkKHRoaXMubG9jYXRvcnMudGFiKHRpdGxlKSlcbiAgICAgICAgICAgIGlmICh0YWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0YWJzWzBdLmNsaWNrKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBhd2FpdCB0YWJDb250YWluZXIuJChgLi8vYVtzdGFydHMtd2l0aChAYXJpYS1sYWJlbCwgJyR7dGl0bGV9JyldYClcbiAgICAgICAgICAgICAgICBhd2FpdCBsYWJlbC5jbGljaygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFRpdGxlQmFyKHRoaXMubG9jYXRvck1hcCkuc2VsZWN0KCdWaWV3JywgdGl0bGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlc2l6ZSAobGFiZWw6IHN0cmluZykge1xuICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZSh0cnVlKVxuICAgICAgICBsZXQgYWN0aW9uITogV2ViZHJpdmVySU8uRWxlbWVudFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWN0aW9uID0gYXdhaXQgdGhpcy5lbGVtXG4gICAgICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5nbG9iYWxBY3Rpb25zKVxuICAgICAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvcnMuYWN0aW9uKGxhYmVsKSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyB0aGUgcGFuZWwgaXMgYWxyZWFkeSBtYXhpbWl6ZWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCBhY3Rpb24uY2xpY2soKVxuICAgICAgICB9XG4gICAgfVxufVxuIl19