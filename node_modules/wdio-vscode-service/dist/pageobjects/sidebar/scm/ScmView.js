var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Key } from 'webdriverio';
import { SideBarView } from '../SideBarView.js';
import { ContextMenu } from '../../index.js';
import { ElementWithContextMenu, PageDecorator, BasePage } from '../../utils.js';
import { ScmView as ScmViewLocators } from '../../../locators/1.73.0.js';
import { CMD_KEY } from '../../../constants.js';
/**
 * Page object representing the Source Control view
 *
 * @category Sidebar
 */
let ScmView = class ScmView extends SideBarView {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    async getProvider(title) {
        const providers = await this.getProviders();
        if (!title || providers.length === 1) {
            return providers[0];
        }
        const names = await Promise.all(providers.map(async (item) => item.getTitle()));
        const index = names.findIndex((name) => name === title);
        return index > -1 ? providers[index] : undefined;
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    async getProviders() {
        const headers = await this.providerHeader$$;
        const sections = await Promise.all(headers.map(async (header) => header.$(this.locators.providerRelative)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return Promise.all(sections.map((section) => new ScmProvider(this.locatorMap, section, this)));
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    async initializeRepository() {
        const buttons = await this.initButton$$;
        if (buttons.length > 0) {
            await buttons[0].click();
            return true;
        }
        return false;
    }
};
ScmView = __decorate([
    PageDecorator(ScmViewLocators)
], ScmView);
export { ScmView };
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 *
 * @category Sidebar
 */
let ScmProvider = class ScmProvider extends BasePage {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get title of the scm provider
     */
    async getTitle() {
        return this.providerTitle$.getAttribute('innerHTML');
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    async getType() {
        return this.providerType$.getAttribute('innerHTML');
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    async takeAction(title) {
        const header = await this.providerHeader$;
        let actions = [];
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            actions = (await this.view.getTitlePart().getActions()).map((action) => action.elem);
        }
        else {
            await this.elem.moveTo();
            actions = await header.$$(this.locators.action);
        }
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    async openMoreActions() {
        const header = await this.providerHeader$;
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            return new MoreAction(this.locatorMap, this.view).openContextMenu();
        }
        await this.elem.moveTo();
        return new MoreAction(this.locatorMap, this).openContextMenu();
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    async commitChanges(message) {
        const input = await this.inputField$;
        await input.clearValue();
        await input.addValue(message);
        await browser.action('key')
            .down(CMD_KEY).down(Key.Enter)
            .up(CMD_KEY).up(Key.Enter)
            .perform();
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    async getChanges(staged = false) {
        const changes = await this.getChangeCount(staged);
        const label = staged ? 'STAGED CHANGES' : 'CHANGES';
        let elements = [];
        if (changes > 0) {
            let i = -1;
            elements = await this.changeItem$$;
            for (const [index, item] of elements.entries()) {
                const name = await item.$(this.locators.changeName);
                if (await name.getText() === label) {
                    i = index + 1;
                    break;
                }
            }
            if (i < 0) {
                return [];
            }
            elements = elements.slice(i, i + changes);
        }
        return Promise.all(elements.map((element) => (new ScmChange(this.locatorMap, element, this).wait())));
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    async getChangeCount(staged = false) {
        const rows = staged
            ? await this.stagedChanges$$
            : await this.changes$$;
        if (rows.length < 1) {
            return 0;
        }
        const count = await rows[0].$(this.locators.changeCount);
        return +await count.getText();
    }
};
ScmProvider = __decorate([
    PageDecorator(ScmViewLocators)
], ScmProvider);
export { ScmProvider };
/**
 * Page object representing a SCM change tree item
 *
 * @category Sidebar
 */
let ScmChange = class ScmChange extends ElementWithContextMenu {
    constructor(locators, row, provider) {
        super(locators, row, provider.elem);
        this.provider = provider;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get label as a string
     */
    async getLabel() {
        return this.changeLabel$.getText();
    }
    /**
     * Get description as a string
     */
    async getDescription() {
        const desc = await this.changeDesc$$;
        if (desc.length < 1) {
            return '';
        }
        return desc[0].getText();
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    async getStatus() {
        const res = await this.resource$;
        const status = await res.getAttribute('data-tooltip');
        if (status && status.length > 0) {
            return status;
        }
        return 'folder';
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    async isExpanded() {
        const twisties = await this.expand$$;
        if (twisties.length < 1) {
            return true;
        }
        return (await twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    async toggleExpand(expand) {
        if (await this.isExpanded() !== expand) {
            await this.elem.click();
            return true;
        }
        return false;
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    async takeAction(title) {
        await this.elem.moveTo();
        const actions = await this.action$$;
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
};
ScmChange = __decorate([
    PageDecorator(ScmViewLocators)
], ScmChange);
export { ScmChange };
/**
 * More Action
 *
 * @category Sidebar
 */
let MoreAction = class MoreAction extends ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.more, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    async openContextMenu() {
        await this.elem.click();
        const shadowRootHost = await this.scm.elem.$$('shadow-root-host');
        await browser.keys('Escape');
        if (shadowRootHost.length > 0) {
            if (await this.elem.getAttribute('aria-expanded') !== 'true') {
                await this.elem.click();
            }
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
MoreAction = __decorate([
    PageDecorator(ScmViewLocators)
], MoreAction);
export { MoreAction };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NtVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9zaWRlYmFyL3NjbS9TY21WaWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxHQUFHLEVBQTJCLE1BQU0sYUFBYSxDQUFBO0FBRTFELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUMvQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUE7QUFDNUMsT0FBTyxFQUNILHNCQUFzQixFQUFvQixhQUFhLEVBQWtCLFFBQVEsRUFDcEYsTUFBTSxnQkFBZ0IsQ0FBQTtBQUN2QixPQUFPLEVBQUUsT0FBTyxJQUFJLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQUcvQzs7OztHQUlHO0FBRUksSUFBTSxPQUFPLEdBQWIsTUFBTSxPQUFRLFNBQVEsV0FBbUM7SUFBekQ7O1FBQ0g7O1dBRUc7UUFDSSxlQUFVLEdBQUcsU0FBa0IsQ0FBQTtJQXlDMUMsQ0FBQztJQXZDRzs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBRSxLQUFjO1FBQzdCLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFBO1FBQzNDLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDdEI7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQy9FLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxT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R0FBRyxDQUF1QjtRQVByQzs7V0FFRztRQUNJLGVBQVUsR0FBRyxTQUFrQixDQUFBO0lBT3RDLENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZTtRQUNqQixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7UUFDdkIsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtRQUNqRSxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7UUFFNUIsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQixJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxFQUFFO2dCQUMxRCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7YUFDMUI7WUFDRCxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsTUFBTSxPQUFPLENBQUMsT0FBTyxDQUFDLGdDQUFnQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDaEcsT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFBO1NBQzdEO1FBQ0QsT0FBTyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUE7SUFDbEMsQ0FBQztDQUNKLENBQUE7QUEzQlksVUFBVTtJQUR0QixhQUFhLENBQUMsZUFBZSxDQUFDO0dBQ2xCLFVBQVUsQ0EyQnRCO1NBM0JZLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBLZXksIENoYWluYWJsZVByb21pc2VFbGVtZW50IH0gZnJvbSAnd2ViZHJpdmVyaW8nXG5cbmltcG9ydCB7IFNpZGVCYXJWaWV3IH0gZnJvbSAnLi4vU2lkZUJhclZpZXcuanMnXG5pbXBvcnQgeyBDb250ZXh0TWVudSB9IGZyb20gJy4uLy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgICBFbGVtZW50V2l0aENvbnRleHRNZW51LCBWU0NvZGVMb2NhdG9yTWFwLCBQYWdlRGVjb3JhdG9yLCBJUGFnZURlY29yYXRvciwgQmFzZVBhZ2Vcbn0gZnJvbSAnLi4vLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBTY21WaWV3IGFzIFNjbVZpZXdMb2NhdG9ycyB9IGZyb20gJy4uLy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcbmltcG9ydCB7IENNRF9LRVkgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NtVmlldyBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBQYWdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIFNvdXJjZSBDb250cm9sIHZpZXdcbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihTY21WaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU2NtVmlldyBleHRlbmRzIFNpZGVCYXJWaWV3PHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NjbVZpZXcnIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBHZXQgU0NNIHByb3ZpZGVyIChyZXBvc2l0b3J5KSBieSB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5XG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gU2NtUHJvdmlkZXIgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvdmlkZXIgKHRpdGxlPzogc3RyaW5nKTogUHJvbWlzZTxTY21Qcm92aWRlciB8IHVuZGVmaW5lZD4ge1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVycygpXG4gICAgICAgIGlmICghdGl0bGUgfHwgcHJvdmlkZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1swXVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvdmlkZXJzLm1hcChhc3luYyAoaXRlbSkgPT4gaXRlbS5nZXRUaXRsZSgpKSlcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5maW5kSW5kZXgoKG5hbWUpID0+IG5hbWUgPT09IHRpdGxlKVxuXG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcHJvdmlkZXJzW2luZGV4XSA6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgU0NNIHByb3ZpZGVyc1xuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIFNjbVByb3ZpZGVyIGFycmF5XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvdmlkZXJzICgpOiBQcm9taXNlPFNjbVByb3ZpZGVyW10+IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMucHJvdmlkZXJIZWFkZXIkJFxuICAgICAgICBjb25zdCBzZWN0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKGhlYWRlcnMubWFwKGFzeW5jIChoZWFkZXIpID0+IGhlYWRlci4kKHRoaXMubG9jYXRvcnMucHJvdmlkZXJSZWxhdGl2ZSkpKVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2VjdGlvbnMubWFwKChzZWN0aW9uKSA9PiBuZXcgU2NtUHJvdmlkZXIodGhpcy5sb2NhdG9yTWFwLCBzZWN0aW9uIGFzIGFueSwgdGhpcykpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcmVwb3NpdG9yeSBpbiB0aGUgY3VycmVudCBmb2xkZXIgaWYgbm8gU0NNIHByb3ZpZGVyIGlzIGZvdW5kXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWN0aW9uIHdhcyBjb21wbGV0ZWQgc3VjY2VzZnVsbHksIGZhbHNlIGlmIGEgcHJvdmlkZXIgYWxyZWFkeSBleGlzdHNcbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplUmVwb3NpdG9yeSAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbnMgPSBhd2FpdCB0aGlzLmluaXRCdXR0b24kJFxuICAgICAgICBpZiAoYnV0dG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBidXR0b25zWzBdLmNsaWNrKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjbVByb3ZpZGVyIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4geyB9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyBhIHJlcG9zaXRvcnkgaW4gdGhlIHNvdXJjZSBjb250cm9sIHZpZXdcbiAqIE1hcHMgcm91Z2hseSB0byBhIHZpZXcgc2VjdGlvbiBvZiB0aGUgc291cmNlIGNvbnRyb2wgdmlld1xuICpcbiAqIEBjYXRlZ29yeSBTaWRlYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNjbVZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBTY21Qcm92aWRlciBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1NjbVZpZXcnIGFzIGNvbnN0XG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbWVudDogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyB2aWV3OiBTY21WaWV3XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBlbGVtZW50LCB2aWV3LmVsZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRpdGxlIG9mIHRoZSBzY20gcHJvdmlkZXJcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUaXRsZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJUaXRsZSQuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0eXBlIG9mIHRoZSBzY20gcHJvdmlkZXIgKGUuZy4gR2l0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldFR5cGUgKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyVHlwZSQuZ2V0QXR0cmlidXRlKCdpbm5lckhUTUwnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gYWN0aW9uIGJ1dHRvbiBmb3IgdGhlIFNDTSBwcm92aWRlciBieSB0aXRsZSBhbmQgY2xpY2sgaXQuIChlLmcgJ0NvbW1pdCcpXG4gICAgICogQHBhcmFtIHRpdGxlIFRpdGxlIG9mIHRoZSBhY3Rpb24gYnV0dG9uIHRvIGNsaWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYWN0aW9uIGNvdWxkIGJlIHBlcmZvcm1lZCwgZmFsc2UgaWYgdGhlIGJ1dHRvbiBkb2Vzbid0IGV4aXN0XG4gICAgICovXG4gICAgYXN5bmMgdGFrZUFjdGlvbiAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVySGVhZGVyJFxuICAgICAgICBsZXQgYWN0aW9uczogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD5bXSA9IFtdXG4gICAgICAgIGlmICgoYXdhaXQgaGVhZGVyLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkuaW5kZXhPZignaGlkZGVuJykgPiAtMSkge1xuICAgICAgICAgICAgYWN0aW9ucyA9IChhd2FpdCB0aGlzLnZpZXcuZ2V0VGl0bGVQYXJ0KCkuZ2V0QWN0aW9ucygpKS5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLmVsZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0ubW92ZVRvKClcbiAgICAgICAgICAgIGFjdGlvbnMgPSBhd2FpdCBoZWFkZXIuJCQodGhpcy5sb2NhdG9ycy5hY3Rpb24pIGFzIGFueSBhcyBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PltdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24uZ2V0QXR0cmlidXRlKCd0aXRsZScpKSlcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IHRpdGxlKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBhd2FpdCBhY3Rpb25zW2luZGV4XS5jbGljaygpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjb250ZXh0IG1lbnUgdXNpbmcgdGhlICdNb3JlIEFjdGlvbnMuLi4nIGJ1dHRvblxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgQ29udGV4dE1lbnUgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3Blbk1vcmVBY3Rpb25zICgpOiBQcm9taXNlPENvbnRleHRNZW51PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMucHJvdmlkZXJIZWFkZXIkXG4gICAgICAgIGlmICgoYXdhaXQgaGVhZGVyLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkuaW5kZXhPZignaGlkZGVuJykgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3JlQWN0aW9uKHRoaXMubG9jYXRvck1hcCwgdGhpcy52aWV3KS5vcGVuQ29udGV4dE1lbnUoKVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5tb3ZlVG8oKVxuICAgICAgICByZXR1cm4gbmV3IE1vcmVBY3Rpb24odGhpcy5sb2NhdG9yTWFwLCB0aGlzKS5vcGVuQ29udGV4dE1lbnUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGwgaW4gdGhlIG1lc3NhZ2UgZmllbGQgYW5kIHNlbmQgY3RybC9jbWQgKyBlbnRlciB0byBjb21taXQgdGhlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgY29tbWl0IG1lc3NhZ2UgdG8gdXNlXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgb25jZSB0aGUga2V5cHJlc3NlcyBhcmUgc2VudFxuICAgICAqL1xuICAgIGFzeW5jIGNvbW1pdENoYW5nZXMgKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMuaW5wdXRGaWVsZCRcbiAgICAgICAgYXdhaXQgaW5wdXQuY2xlYXJWYWx1ZSgpXG4gICAgICAgIGF3YWl0IGlucHV0LmFkZFZhbHVlKG1lc3NhZ2UpXG4gICAgICAgIGF3YWl0IGJyb3dzZXIuYWN0aW9uKCdrZXknKVxuICAgICAgICAgICAgLmRvd24oQ01EX0tFWSkuZG93bihLZXkuRW50ZXIpXG4gICAgICAgICAgICAudXAoQ01EX0tFWSkudXAoS2V5LkVudGVyKVxuICAgICAgICAgICAgLnBlcmZvcm0oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBwYWdlIG9iamVjdHMgZm9yIGFsbCB0cmVlIGl0ZW1zIHJlcHJlc2VudGluZyBpbmRpdmlkdWFsIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhZ2VkIHdoZW4gdHJ1ZSwgZmluZHMgc3RhZ2VkIGNoYW5nZXMgb3RoZXJ3aXNlIGZpbmRzIHVuc3RhZ2VkIGNoYW5nZXNcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBTY21DaGFuZ2Ugb2JqZWN0IGFycmF5XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2hhbmdlcyAoc3RhZ2VkID0gZmFsc2UpOiBQcm9taXNlPFNjbUNoYW5nZVtdPiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCB0aGlzLmdldENoYW5nZUNvdW50KHN0YWdlZClcbiAgICAgICAgY29uc3QgbGFiZWwgPSBzdGFnZWQgPyAnU1RBR0VEIENIQU5HRVMnIDogJ0NIQU5HRVMnXG5cbiAgICAgICAgbGV0IGVsZW1lbnRzOiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PltdID0gW11cbiAgICAgICAgaWYgKGNoYW5nZXMgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IC0xXG4gICAgICAgICAgICBlbGVtZW50cyA9IGF3YWl0IHRoaXMuY2hhbmdlSXRlbSQkIGFzIGFueVxuICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGl0ZW1dIG9mIGVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBpdGVtLiQodGhpcy5sb2NhdG9ycy5jaGFuZ2VOYW1lKVxuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBuYW1lLmdldFRleHQoKSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5zbGljZShpLCBpICsgY2hhbmdlcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBlbGVtZW50cy5tYXAoKGVsZW1lbnQpID0+IChcbiAgICAgICAgICAgICAgICBuZXcgU2NtQ2hhbmdlKHRoaXMubG9jYXRvck1hcCwgZWxlbWVudCwgdGhpcykud2FpdCgpXG4gICAgICAgICAgICApKVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhbmdlcyBmb3IgYSBnaXZlbiBzZWN0aW9uXG4gICAgICogQHBhcmFtIHN0YWdlZCB3aGVuIHRydWUsIGNvdW50cyB0aGUgc3RhZ2VkIGNoYW5nZXMsIHVuc3RhZ2VkIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIG51bWJlciBvZiBjaGFuZ2VzIGluIHRoZSBnaXZlbiBzdWJzZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2hhbmdlQ291bnQgKHN0YWdlZCA9IGZhbHNlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgY29uc3Qgcm93cyA9IHN0YWdlZFxuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLnN0YWdlZENoYW5nZXMkJFxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmNoYW5nZXMkJFxuXG4gICAgICAgIGlmIChyb3dzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBhd2FpdCByb3dzWzBdLiQodGhpcy5sb2NhdG9ycy5jaGFuZ2VDb3VudClcbiAgICAgICAgcmV0dXJuICthd2FpdCBjb3VudC5nZXRUZXh0KClcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NtQ2hhbmdlIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4geyB9XG4vKipcbiAqIFBhZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyBhIFNDTSBjaGFuZ2UgdHJlZSBpdGVtXG4gKlxuICogQGNhdGVnb3J5IFNpZGViYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU2NtVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFNjbUNoYW5nZSBleHRlbmRzIEVsZW1lbnRXaXRoQ29udGV4dE1lbnU8dHlwZW9mIFNjbVZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnU2NtVmlldycgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHJvdzogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyBwcm92aWRlcjogU2NtUHJvdmlkZXJcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9jYXRvcnMsIHJvdywgcHJvdmlkZXIuZWxlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFiZWwgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYWJlbCAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlTGFiZWwkLmdldFRleHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkZXNjcmlwdGlvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldERlc2NyaXB0aW9uICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBkZXNjID0gYXdhaXQgdGhpcy5jaGFuZ2VEZXNjJCRcbiAgICAgICAgaWYgKGRlc2MubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NbMF0uZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0dXMgc3RyaW5nIChlLmcuICdNb2RpZmllZCcpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdHVzICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlc291cmNlJFxuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCByZXMuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAnKVxuXG4gICAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2ZvbGRlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGlmIHRoZSBpdGVtIGlzIGV4cGFuZGVkXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiBjaGFuZ2UgaXMgZXhwYW5kZWQsIHRvIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGlzRXhwYW5kZWQgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCB0d2lzdGllcyA9IGF3YWl0IHRoaXMuZXhwYW5kJCRcbiAgICAgICAgaWYgKHR3aXN0aWVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhd2FpdCB0d2lzdGllc1swXS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLmluZGV4T2YoJ2NvbGxhcHNlZCcpIDwgMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBvciBjb2xsYXBzZSBhIGNoYW5nZSBpdGVtIGlmIHBvc3NpYmxlLCBvbmx5IHdvcmtzIGZvciBmb2xkZXJzIGluIGhpZXJhcmNoaWNhbCB2aWV3IG1vZGVcbiAgICAgKiBAcGFyYW0gZXhwYW5kIHRydWUgdG8gZXhwYW5kIHRoZSBpdGVtLCBmYWxzZSB0byBjb2xsYXBzZVxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgdGhlIGl0ZW0gY2hhbmdlZCBzdGF0ZSwgdG8gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgdG9nZ2xlRXhwYW5kIChleHBhbmQ6IGJvb2xlYW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaXNFeHBhbmRlZCgpICE9PSBleHBhbmQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGNsaWNrIGFuIGFjdGlvbiBidXR0b24gYXZhaWxhYmxlIHRvIGEgZ2l2ZW4gY2hhbmdlIHRyZWUgaXRlbVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgYWN0aW9uIGJ1dHRvbiAoZS5nICdTdGFnZSBDaGFuZ2VzJylcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIHRoZSBhY3Rpb24gd2FzIHBlcmZvcm1lZCBzdWNjZXNzZnVsbHksXG4gICAgICogZmFsc2UgaWYgdGhlIGdpdmVuIGJ1dHRvbiBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIHRha2VBY3Rpb24gKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbGVtLm1vdmVUbygpXG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmFjdGlvbiQkXG4gICAgICAgIGNvbnN0IG5hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLmdldEF0dHJpYnV0ZSgndGl0bGUnKSkpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSB0aXRsZSlcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgYXdhaXQgYWN0aW9uc1tpbmRleF0uY2xpY2soKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9yZUFjdGlvbiBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBTY21WaWV3TG9jYXRvcnM+IHsgfVxuLyoqXG4gKiBNb3JlIEFjdGlvblxuICpcbiAqIEBjYXRlZ29yeSBTaWRlYmFyXG4gKi9cbkBQYWdlRGVjb3JhdG9yKFNjbVZpZXdMb2NhdG9ycylcbmV4cG9ydCBjbGFzcyBNb3JlQWN0aW9uIGV4dGVuZHMgRWxlbWVudFdpdGhDb250ZXh0TWVudTx0eXBlb2YgU2NtVmlld0xvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTY21WaWV3JyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgcHVibGljIHNjbTogU2NtUHJvdmlkZXIgfCBTY21WaWV3XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBsb2NhdG9ycy5TY21WaWV3Lm1vcmUgYXMgc3RyaW5nLCBzY20uZWxlbSlcbiAgICB9XG5cbiAgICBhc3luYyBvcGVuQ29udGV4dE1lbnUgKCk6IFByb21pc2U8Q29udGV4dE1lbnU+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbGVtLmNsaWNrKClcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdEhvc3QgPSBhd2FpdCB0aGlzLnNjbS5lbGVtLiQkKCdzaGFkb3ctcm9vdC1ob3N0JylcbiAgICAgICAgYXdhaXQgYnJvd3Nlci5rZXlzKCdFc2NhcGUnKVxuXG4gICAgICAgIGlmIChzaGFkb3dSb290SG9zdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5lbGVtLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpICE9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0uY2xpY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9ICQoYXdhaXQgYnJvd3Nlci5leGVjdXRlKCdyZXR1cm4gYXJndW1lbnRzWzBdLnNoYWRvd1Jvb3QnLCBzaGFkb3dSb290SG9zdFswXSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRleHRNZW51KHRoaXMubG9jYXRvck1hcCwgc2hhZG93Um9vdCkud2FpdCgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLm9wZW5Db250ZXh0TWVudSgpXG4gICAgfVxufVxuIl19