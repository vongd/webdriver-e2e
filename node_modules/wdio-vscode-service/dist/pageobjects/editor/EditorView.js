var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { TextEditor, DiffEditor, SettingsEditor } from '../index.js';
import { PageDecorator, BasePage, ElementWithContextMenu } from '../utils.js';
import { EditorView as EditorViewLocators, Editor as EditorLocatorsObj } from '../../locators/1.73.0.js';
/**
 * View handling the open editors
 *
 * @category Editor
 */
let EditorView = class EditorView extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving to Editor object
     */
    async openEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.openEditor(title);
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @param groupIndex zero based index for the editor group (0 for the left most group)
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.closeEditor(title);
    }
    /**
     * Close all open editor tabs
     * @param groupIndex optional index to specify an editor group
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors(groupIndex) {
        let groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            await groups[0].closeAllEditors();
            return;
        }
        while (groups.length > 0 && (await groups[0].getOpenEditorTitles()).length > 0) {
            await groups[0].closeAllEditors();
            groups = await this.getEditorGroups();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @param groupIndex optional index to specify an editor group, if left empty will search all groups
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenEditorTitles();
        }
        const titles = [];
        for (const group of groups) {
            titles.push(...(await group.getOpenEditorTitles()));
        }
        return titles;
    }
    /**
     * Retrieve an editor tab from a given group by title
     * @param title title of the tab
     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getTabByTitle(title);
    }
    /**
     * Retrieve all open editor tabs
     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs(groupIndex) {
        const groups = await this.getEditorGroups();
        if (groupIndex !== undefined) {
            return groups[groupIndex].getOpenTabs();
        }
        const tabs = [];
        for (const group of groups) {
            tabs.push(...(await group.getOpenTabs()));
        }
        return tabs;
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve all editor groups in a list, sorted left to right
     * @returns promise resolving to an array of EditorGroup objects
     */
    async getEditorGroups() {
        const elements = await this.editorGroup$$;
        const groups = await Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorGroup(this.locatorMap, element, this).wait())));
        // sort the groups by x coordinates, so the leftmost is always at index 0
        for (let i = 0; i < groups.length - 1; i += 1) {
            for (let j = 0; j < groups.length - i - 1; j += 1) {
                if ((await groups[j].elem.getLocation('x')) > (await groups[j + 1].elem.getLocation('x'))) {
                    const temp = groups[j];
                    groups[j] = groups[j + 1];
                    groups[j + 1] = temp;
                }
            }
        }
        return groups;
    }
    /**
     * Retrieve an editor group with a given index (counting from left to right)
     * @param index zero based index of the editor group (leftmost group has index 0)
     * @returns promise resolving to an EditorGroup object
     */
    async getEditorGroup(index) {
        return (await this.getEditorGroups())[index];
    }
    /**
     * Get editor actions of a select editor group
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to list of WebElement objects
     */
    async getActions(groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getActions();
    }
    /**
     * Get editor action of a select editor group, search by title
     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0
     * @returns promise resolving to WebElement object if found, undefined otherwise
     */
    async getAction(title, groupIndex = 0) {
        const group = await this.getEditorGroup(groupIndex);
        return group.getAction(title);
    }
};
EditorView = __decorate([
    PageDecorator(EditorViewLocators)
], EditorView);
export { EditorView };
/**
 * Page object representing an editor group
 *
 * @category Editor
 */
let EditorGroup = class EditorGroup extends BasePage {
    constructor(locators, element, view = new EditorView(locators)) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'EditorView';
    }
    /**
     * Switch to an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving to Editor object
     */
    async openEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.select();
        if (await this.settingsEditor$.isExisting()) {
            return new SettingsEditor(this.locatorMap, this).wait();
        }
        if (await this.diffEditor$.isExisting()) {
            return new DiffEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
        }
        return new TextEditor(this.locatorMap, this.locatorMap.Editor.elem, this).wait();
    }
    /**
     * Close an editor tab with the given title
     * @param title title of the tab
     * @returns Promise resolving when the tab's close button is pressed
     */
    async closeEditor(title) {
        const tab = await this.getTabByTitle(title);
        await tab.elem.moveTo();
        const closeButton = await tab.elem.$(this.locators.closeTab);
        await closeButton.click();
    }
    /**
     * Close all open editor tabs
     * @returns Promise resolving once all tabs have had their close button pressed
     */
    async closeAllEditors() {
        let titles = await this.getOpenEditorTitles();
        while (titles.length > 0) {
            await this.closeEditor(titles[0]);
            try {
                // check if the group still exists
                await this.elem.getTagName();
            }
            catch (err) {
                break;
            }
            titles = await this.getOpenEditorTitles();
        }
    }
    /**
     * Retrieve all open editor tab titles in an array
     * @returns Promise resolving to array of editor titles
     */
    async getOpenEditorTitles() {
        const tabs = await this.tab$$;
        const titles = [];
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const title = await new EditorTab(this.locatorMap, tab, this.view).getTitle();
            titles.push(title);
        }
        return titles;
    }
    /**
     * Retrieve an editor tab by title
     * @param title title of the tab
     * @returns promise resolving to EditorTab object
     */
    async getTabByTitle(title) {
        const tabs = await this.tab$$;
        const availableLabels = new Set();
        for (const tab of tabs) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const editorTab = new EditorTab(this.locatorMap, tab, this.view);
            const label = await editorTab.getTitle();
            availableLabels.add(label);
            if (label === title) {
                return editorTab;
            }
        }
        throw new Error(`No editor with title '${title}' found, `
            + `available editor were: ${[...availableLabels].join(', ')}`);
    }
    /**
     * Retrieve all open editor tabs
     * @returns promise resolving to EditorTab list
     */
    async getOpenTabs() {
        const tabs = await this.tab$$;
        return Promise.all(tabs.map(async (tab) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new EditorTab(this.locatorMap, tab, this.view).wait())));
    }
    /**
     * Retrieve the active editor tab
     * @returns promise resolving to EditorTab object, undefined if no tab is active
     */
    async getActiveTab() {
        const tabs = await this.getOpenTabs();
        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')));
        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1);
        if (index > -1) {
            return tabs[index];
        }
        return undefined;
    }
    /**
     * Retrieve the editor action buttons as WebElements
     * @returns promise resolving to list of WebElement objects
     */
    async getActions() {
        return this.actionContainer$.$$(this.locators.actionItem);
    }
    /**
     * Find an editor action button by title
     * @param title title of the button
     * @returns promise resolving to WebElement representing the button if found, undefined otherwise
     */
    async getAction(title) {
        const actions = await this.getActions();
        for (const item of actions) {
            if (await item.getAttribute('title') === title) {
                return item;
            }
        }
        return undefined;
    }
};
EditorGroup = __decorate([
    PageDecorator(EditorViewLocators)
], EditorGroup);
export { EditorGroup };
/**
 * Page object for editor view tab
 *
 * @category Editor
 */
let EditorTab = class EditorTab extends ElementWithContextMenu {
    constructor(locators, element, view) {
        super(locators, element);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'Editor';
    }
    /**
     * Get the tab title as string
     */
    async getTitle() {
        return this.title$.getText();
    }
    /**
     * Select (click) the tab
     */
    async select() {
        await this.elem.click();
    }
};
EditorTab = __decorate([
    PageDecorator(EditorLocatorsObj)
], EditorTab);
export { EditorTab };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdG9yVmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWdlb2JqZWN0cy9lZGl0b3IvRWRpdG9yVmlldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFDcEUsT0FBTyxFQUNILGFBQWEsRUFBa0IsUUFBUSxFQUFFLHNCQUFzQixFQUNsRSxNQUFNLGFBQWEsQ0FBQTtBQUNwQixPQUFPLEVBQ0gsVUFBVSxJQUFJLGtCQUFrQixFQUNoQyxNQUFNLElBQUksaUJBQWlCLEVBQzlCLE1BQU0sMEJBQTBCLENBQUE7QUFHakM7Ozs7R0FJRztBQUVJLElBQU0sVUFBVSxHQUFoQixNQUFNLFVBQVcsU0FBUSxRQUFtQztJQUE1RDs7UUFDSDs7V0FFRztRQUNJLGVBQVUsR0FBRyxZQUFxQixDQUFBO0lBNEo3QyxDQUFDO0lBMUpHOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFhLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ25ELE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFFLEtBQWEsRUFBRSxVQUFVLEdBQUcsQ0FBQztRQUM1QyxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbkQsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBRSxVQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FB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cnQgdHlwZSB7IENoYWluYWJsZVByb21pc2VFbGVtZW50IH0gZnJvbSAnd2ViZHJpdmVyaW8nXG5cbmltcG9ydCB7IFRleHRFZGl0b3IsIERpZmZFZGl0b3IsIFNldHRpbmdzRWRpdG9yIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICAgIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yLCBCYXNlUGFnZSwgRWxlbWVudFdpdGhDb250ZXh0TWVudSwgVlNDb2RlTG9jYXRvck1hcFxufSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7XG4gICAgRWRpdG9yVmlldyBhcyBFZGl0b3JWaWV3TG9jYXRvcnMsXG4gICAgRWRpdG9yIGFzIEVkaXRvckxvY2F0b3JzT2JqXG59IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBFZGl0b3JWaWV3IGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIEVkaXRvclZpZXdMb2NhdG9ycz4ge31cbi8qKlxuICogVmlldyBoYW5kbGluZyB0aGUgb3BlbiBlZGl0b3JzXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihFZGl0b3JWaWV3TG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgRWRpdG9yVmlldyBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBFZGl0b3JWaWV3TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ0VkaXRvclZpZXcnIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdG8gYW4gZWRpdG9yIHRhYiB3aXRoIHRoZSBnaXZlbiB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBmb3IgdGhlIGVkaXRvciBncm91cCAoMCBmb3IgdGhlIGxlZnQgbW9zdCBncm91cClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3Igb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgb3BlbkVkaXRvciAodGl0bGU6IHN0cmluZywgZ3JvdXBJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwKGdyb3VwSW5kZXgpXG4gICAgICAgIHJldHVybiBncm91cC5vcGVuRWRpdG9yKHRpdGxlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFuIGVkaXRvciB0YWIgd2l0aCB0aGUgZ2l2ZW4gdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggZm9yIHRoZSBlZGl0b3IgZ3JvdXAgKDAgZm9yIHRoZSBsZWZ0IG1vc3QgZ3JvdXApXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgdGFiJ3MgY2xvc2UgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUVkaXRvciAodGl0bGU6IHN0cmluZywgZ3JvdXBJbmRleCA9IDApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwKGdyb3VwSW5kZXgpXG4gICAgICAgIHJldHVybiBncm91cC5jbG9zZUVkaXRvcih0aXRsZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgb3BlbiBlZGl0b3IgdGFic1xuICAgICAqIEBwYXJhbSBncm91cEluZGV4IG9wdGlvbmFsIGluZGV4IHRvIHNwZWNpZnkgYW4gZWRpdG9yIGdyb3VwXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgb25jZSBhbGwgdGFicyBoYXZlIGhhZCB0aGVpciBjbG9zZSBidXR0b24gcHJlc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlQWxsRWRpdG9ycyAoZ3JvdXBJbmRleD86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgZ3JvdXBzID0gYXdhaXQgdGhpcy5nZXRFZGl0b3JHcm91cHMoKVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBncm91cHNbMF0uY2xvc2VBbGxFZGl0b3JzKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGdyb3Vwcy5sZW5ndGggPiAwICYmIChhd2FpdCBncm91cHNbMF0uZ2V0T3BlbkVkaXRvclRpdGxlcygpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBncm91cHNbMF0uY2xvc2VBbGxFZGl0b3JzKClcbiAgICAgICAgICAgIGdyb3VwcyA9IGF3YWl0IHRoaXMuZ2V0RWRpdG9yR3JvdXBzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBvcGVuIGVkaXRvciB0YWIgdGl0bGVzIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggb3B0aW9uYWwgaW5kZXggdG8gc3BlY2lmeSBhbiBlZGl0b3IgZ3JvdXAsIGlmIGxlZnQgZW1wdHkgd2lsbCBzZWFyY2ggYWxsIGdyb3Vwc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIGVkaXRvciB0aXRsZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcGVuRWRpdG9yVGl0bGVzIChncm91cEluZGV4PzogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCBncm91cHMgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpXG4gICAgICAgIGlmIChncm91cEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cHNbZ3JvdXBJbmRleF0uZ2V0T3BlbkVkaXRvclRpdGxlcygpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGl0bGVzOiBzdHJpbmdbXSA9IFtdXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICAgICAgICB0aXRsZXMucHVzaCguLi4oYXdhaXQgZ3JvdXAuZ2V0T3BlbkVkaXRvclRpdGxlcygpKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGl0bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYW4gZWRpdG9yIHRhYiBmcm9tIGEgZ2l2ZW4gZ3JvdXAgYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGVkaXRvciBncm91cCwgZGVmYXVsdCAwIChsZWZ0bW9zdCBvbmUpXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRhYkJ5VGl0bGUgKHRpdGxlOiBzdHJpbmcsIGdyb3VwSW5kZXggPSAwKTogUHJvbWlzZTxFZGl0b3JUYWI+IHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwKGdyb3VwSW5kZXgpXG4gICAgICAgIHJldHVybiBncm91cC5nZXRUYWJCeVRpdGxlKHRpdGxlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBvcGVuIGVkaXRvciB0YWJzXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggaW5kZXggb2YgZ3JvdXAgdG8gc2VhcmNoIGZvciB0YWJzLCBpZiBsZWZ0IHVuZGVmaW5lZCwgYWxsIGdyb3VwcyBhcmUgc2VhcmNoZWRcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgbGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGdldE9wZW5UYWJzIChncm91cEluZGV4PzogbnVtYmVyKTogUHJvbWlzZTxFZGl0b3JUYWJbXT4ge1xuICAgICAgICBjb25zdCBncm91cHMgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpXG4gICAgICAgIGlmIChncm91cEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cHNbZ3JvdXBJbmRleF0uZ2V0T3BlblRhYnMoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYnM6IEVkaXRvclRhYltdID0gW11cbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICAgICAgICAgIHRhYnMucHVzaCguLi4oYXdhaXQgZ3JvdXAuZ2V0T3BlblRhYnMoKSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYWN0aXZlIGVkaXRvciB0YWJcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgb2JqZWN0LCB1bmRlZmluZWQgaWYgbm8gdGFiIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGl2ZVRhYiAoKTogUHJvbWlzZTxFZGl0b3JUYWIgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMuZ2V0T3BlblRhYnMoKVxuICAgICAgICBjb25zdCBrbGFzc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwodGFicy5tYXAoYXN5bmMgKHRhYikgPT4gdGFiLmVsZW0uZ2V0QXR0cmlidXRlKCdjbGFzcycpKSlcbiAgICAgICAgY29uc3QgaW5kZXggPSBrbGFzc2VzLmZpbmRJbmRleCgoa2xhc3MpID0+IGtsYXNzLmluZGV4T2YoJ2FjdGl2ZScpID4gLTEpXG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWJzW2luZGV4XVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgZWRpdG9yIGdyb3VwcyBpbiBhIGxpc3QsIHNvcnRlZCBsZWZ0IHRvIHJpZ2h0XG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgRWRpdG9yR3JvdXAgb2JqZWN0c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEVkaXRvckdyb3VwcyAoKTogUHJvbWlzZTxFZGl0b3JHcm91cFtdPiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdGhpcy5lZGl0b3JHcm91cCQkXG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgZWxlbWVudHMubWFwKGFzeW5jIChlbGVtZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBuZXcgRWRpdG9yR3JvdXAodGhpcy5sb2NhdG9yTWFwLCBlbGVtZW50IGFzIGFueSwgdGhpcykud2FpdCgpXG4gICAgICAgICAgICApKVxuICAgICAgICApXG5cbiAgICAgICAgLy8gc29ydCB0aGUgZ3JvdXBzIGJ5IHggY29vcmRpbmF0ZXMsIHNvIHRoZSBsZWZ0bW9zdCBpcyBhbHdheXMgYXQgaW5kZXggMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aCAtIGkgLSAxOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IGdyb3Vwc1tqXS5lbGVtLmdldExvY2F0aW9uKCd4JykpID4gKGF3YWl0IGdyb3Vwc1tqICsgMV0uZWxlbS5nZXRMb2NhdGlvbigneCcpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gZ3JvdXBzW2pdXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tqXSA9IGdyb3Vwc1tqICsgMV1cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2ogKyAxXSA9IHRlbXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3Vwc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFuIGVkaXRvciBncm91cCB3aXRoIGEgZ2l2ZW4gaW5kZXggKGNvdW50aW5nIGZyb20gbGVmdCB0byByaWdodClcbiAgICAgKiBAcGFyYW0gaW5kZXggemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZWRpdG9yIGdyb3VwIChsZWZ0bW9zdCBncm91cCBoYXMgaW5kZXggMClcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBhbiBFZGl0b3JHcm91cCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRFZGl0b3JHcm91cCAoaW5kZXg6IG51bWJlcik6IFByb21pc2U8RWRpdG9yR3JvdXA+IHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwcygpKVtpbmRleF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZWRpdG9yIGFjdGlvbnMgb2YgYSBzZWxlY3QgZWRpdG9yIGdyb3VwXG4gICAgICogQHBhcmFtIGdyb3VwSW5kZXggemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZWRpdG9yIGdyb3VwIChsZWZ0bW9zdCBncm91cCBoYXMgaW5kZXggMCksIGRlZmF1bHQgMFxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIGxpc3Qgb2YgV2ViRWxlbWVudCBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWN0aW9ucyAoZ3JvdXBJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwKGdyb3VwSW5kZXgpXG4gICAgICAgIHJldHVybiBncm91cC5nZXRBY3Rpb25zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZWRpdG9yIGFjdGlvbiBvZiBhIHNlbGVjdCBlZGl0b3IgZ3JvdXAsIHNlYXJjaCBieSB0aXRsZVxuICAgICAqIEBwYXJhbSBncm91cEluZGV4IHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGVkaXRvciBncm91cCAobGVmdG1vc3QgZ3JvdXAgaGFzIGluZGV4IDApLCBkZWZhdWx0IDBcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBXZWJFbGVtZW50IG9iamVjdCBpZiBmb3VuZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGlvbiAodGl0bGU6IHN0cmluZywgZ3JvdXBJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBhd2FpdCB0aGlzLmdldEVkaXRvckdyb3VwKGdyb3VwSW5kZXgpXG4gICAgICAgIHJldHVybiBncm91cC5nZXRBY3Rpb24odGl0bGUpXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRvckdyb3VwIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIEVkaXRvclZpZXdMb2NhdG9ycz4ge31cbi8qKlxuICogUGFnZSBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGVkaXRvciBncm91cFxuICpcbiAqIEBjYXRlZ29yeSBFZGl0b3JcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoRWRpdG9yVmlld0xvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIEVkaXRvckdyb3VwIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIEVkaXRvclZpZXdMb2NhdG9ycz4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnRWRpdG9yVmlldycgYXMgY29uc3RcblxuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIGVsZW1lbnQ6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgdmlldyA9IG5ldyBFZGl0b3JWaWV3KGxvY2F0b3JzKVxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgZWxlbWVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdG8gYW4gZWRpdG9yIHRhYiB3aXRoIHRoZSBnaXZlbiB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5FZGl0b3IgKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPFNldHRpbmdzRWRpdG9yIHwgRGlmZkVkaXRvciB8IFRleHRFZGl0b3I+IHtcbiAgICAgICAgY29uc3QgdGFiID0gYXdhaXQgdGhpcy5nZXRUYWJCeVRpdGxlKHRpdGxlKVxuICAgICAgICBhd2FpdCB0YWIuc2VsZWN0KClcblxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zZXR0aW5nc0VkaXRvciQuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldHRpbmdzRWRpdG9yKFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcCxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApLndhaXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuZGlmZkVkaXRvciQuaXNFeGlzdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERpZmZFZGl0b3IoXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdG9yTWFwLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcC5FZGl0b3IuZWxlbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKS53YWl0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVkaXRvcihcbiAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcCxcbiAgICAgICAgICAgIHRoaXMubG9jYXRvck1hcC5FZGl0b3IuZWxlbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICkud2FpdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYW4gZWRpdG9yIHRhYiB3aXRoIHRoZSBnaXZlbiB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgdGFiXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgdGFiJ3MgY2xvc2UgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUVkaXRvciAodGl0bGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0YWIgPSBhd2FpdCB0aGlzLmdldFRhYkJ5VGl0bGUodGl0bGUpXG4gICAgICAgIGF3YWl0IHRhYi5lbGVtLm1vdmVUbygpXG4gICAgICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gYXdhaXQgdGFiLmVsZW0uJCh0aGlzLmxvY2F0b3JzLmNsb3NlVGFiKVxuICAgICAgICBhd2FpdCBjbG9zZUJ1dHRvbi5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIG9wZW4gZWRpdG9yIHRhYnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBvbmNlIGFsbCB0YWJzIGhhdmUgaGFkIHRoZWlyIGNsb3NlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2VBbGxFZGl0b3JzICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IHRpdGxlcyA9IGF3YWl0IHRoaXMuZ2V0T3BlbkVkaXRvclRpdGxlcygpXG4gICAgICAgIHdoaWxlICh0aXRsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbG9zZUVkaXRvcih0aXRsZXNbMF0pXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBncm91cCBzdGlsbCBleGlzdHNcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVsZW0uZ2V0VGFnTmFtZSgpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGl0bGVzID0gYXdhaXQgdGhpcy5nZXRPcGVuRWRpdG9yVGl0bGVzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBvcGVuIGVkaXRvciB0YWIgdGl0bGVzIGluIGFuIGFycmF5XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgZWRpdG9yIHRpdGxlc1xuICAgICAqL1xuICAgIGFzeW5jIGdldE9wZW5FZGl0b3JUaXRsZXMgKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMudGFiJCRcbiAgICAgICAgY29uc3QgdGl0bGVzID0gW11cbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gYXdhaXQgbmV3IEVkaXRvclRhYih0aGlzLmxvY2F0b3JNYXAsIHRhYiBhcyBhbnksIHRoaXMudmlldykuZ2V0VGl0bGUoKVxuICAgICAgICAgICAgdGl0bGVzLnB1c2godGl0bGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpdGxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFuIGVkaXRvciB0YWIgYnkgdGl0bGVcbiAgICAgKiBAcGFyYW0gdGl0bGUgdGl0bGUgb2YgdGhlIHRhYlxuICAgICAqIEByZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHRvIEVkaXRvclRhYiBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUYWJCeVRpdGxlICh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxFZGl0b3JUYWI+IHtcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMudGFiJCRcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlTGFiZWxzID0gbmV3IFNldCgpXG4gICAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBjb25zdCBlZGl0b3JUYWIgPSBuZXcgRWRpdG9yVGFiKHRoaXMubG9jYXRvck1hcCwgdGFiIGFzIGFueSwgdGhpcy52aWV3KVxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBhd2FpdCBlZGl0b3JUYWIuZ2V0VGl0bGUoKVxuICAgICAgICAgICAgYXZhaWxhYmxlTGFiZWxzLmFkZChsYWJlbClcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yVGFiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vIGVkaXRvciB3aXRoIHRpdGxlICcke3RpdGxlfScgZm91bmQsIGBcbiAgICAgICAgICAgICsgYGF2YWlsYWJsZSBlZGl0b3Igd2VyZTogJHtbLi4uYXZhaWxhYmxlTGFiZWxzXS5qb2luKCcsICcpfWBcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBvcGVuIGVkaXRvciB0YWJzXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gRWRpdG9yVGFiIGxpc3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcGVuVGFicyAoKTogUHJvbWlzZTxFZGl0b3JUYWJbXT4ge1xuICAgICAgICBjb25zdCB0YWJzID0gYXdhaXQgdGhpcy50YWIkJFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0YWJzLm1hcChhc3luYyAodGFiKSA9PiAoXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBuZXcgRWRpdG9yVGFiKHRoaXMubG9jYXRvck1hcCwgdGFiIGFzIGFueSwgdGhpcy52aWV3KS53YWl0KClcbiAgICAgICAgICAgICkpXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYWN0aXZlIGVkaXRvciB0YWJcbiAgICAgKiBAcmV0dXJucyBwcm9taXNlIHJlc29sdmluZyB0byBFZGl0b3JUYWIgb2JqZWN0LCB1bmRlZmluZWQgaWYgbm8gdGFiIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGl2ZVRhYiAoKTogUHJvbWlzZTxFZGl0b3JUYWIgfCB1bmRlZmluZWQ+IHtcbiAgICAgICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMuZ2V0T3BlblRhYnMoKVxuICAgICAgICBjb25zdCBrbGFzc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwodGFicy5tYXAoYXN5bmMgKHRhYikgPT4gdGFiLmVsZW0uZ2V0QXR0cmlidXRlKCdjbGFzcycpKSlcbiAgICAgICAgY29uc3QgaW5kZXggPSBrbGFzc2VzLmZpbmRJbmRleCgoa2xhc3MpID0+IGtsYXNzLmluZGV4T2YoJ2FjdGl2ZScpID4gLTEpXG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWJzW2luZGV4XVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZWRpdG9yIGFjdGlvbiBidXR0b25zIGFzIFdlYkVsZW1lbnRzXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gbGlzdCBvZiBXZWJFbGVtZW50IG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3Rpb25zICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uQ29udGFpbmVyJC4kJCh0aGlzLmxvY2F0b3JzLmFjdGlvbkl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBlZGl0b3IgYWN0aW9uIGJ1dHRvbiBieSB0aXRsZVxuICAgICAqIEBwYXJhbSB0aXRsZSB0aXRsZSBvZiB0aGUgYnV0dG9uXG4gICAgICogQHJldHVybnMgcHJvbWlzZSByZXNvbHZpbmcgdG8gV2ViRWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGJ1dHRvbiBpZiBmb3VuZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGlvbiAodGl0bGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0gYXdhaXQgdGhpcy5nZXRBY3Rpb25zKClcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBpdGVtLmdldEF0dHJpYnV0ZSgndGl0bGUnKSA9PT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWRpdG9yVGFiIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIEVkaXRvckxvY2F0b3JzT2JqPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgZWRpdG9yIHZpZXcgdGFiXG4gKlxuICogQGNhdGVnb3J5IEVkaXRvclxuICovXG5AUGFnZURlY29yYXRvcihFZGl0b3JMb2NhdG9yc09iailcbmV4cG9ydCBjbGFzcyBFZGl0b3JUYWIgZXh0ZW5kcyBFbGVtZW50V2l0aENvbnRleHRNZW51PHR5cGVvZiBFZGl0b3JMb2NhdG9yc09iaj4ge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGxvY2F0b3JLZXkgPSAnRWRpdG9yJyBhcyBjb25zdFxuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgZWxlbWVudDogQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQ8V2ViZHJpdmVySU8uRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyB2aWV3OiBFZGl0b3JWaWV3XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxvY2F0b3JzLCBlbGVtZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGFiIHRpdGxlIGFzIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRpdGxlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSQuZ2V0VGV4dCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IChjbGljaykgdGhlIHRhYlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZWxlbS5jbGljaygpXG4gICAgfVxufVxuIl19