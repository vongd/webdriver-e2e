var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BasePage, PageDecorator } from '../utils.js';
import { WelcomeContent as WelcomeContentLocators } from '../../locators/1.73.0.js';
/**
 * A button that appears in the welcome content and can be clicked to execute a command.
 *
 * To execute the command bound to this button simply run: `await button.click();`.
 *
 * @category Sidebar
 */
let WelcomeContentButton = class WelcomeContentButton extends BasePage {
    /**
     * @param panel  The panel containing the button in the welcome section
     * @param welcomeSection  The enclosing welcome section
     */
    constructor(locators, panel, welcomeSection) {
        super(locators, panel);
        this.welcomeSection = welcomeSection;
        /**
         * @private
         */
        this.locatorKey = 'WelcomeContent';
    }
    /** Return the title displayed on this button */
    getTitle() {
        return this.elem.getText();
    }
};
WelcomeContentButton = __decorate([
    PageDecorator(WelcomeContentLocators)
], WelcomeContentButton);
export { WelcomeContentButton };
/**
 * A section in an empty custom view, see:
 * https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content
 *
 * The welcome section contains two types of elements: text entries and buttons that can be bound to commands.
 * The text sections can be accessed via [[getTextSections]], the buttons on the
 * other hand via [[getButtons]].
 * This however looses the information of the order of the buttons and lines
 * with respect to each other. This can be remedied by using [[getContents]],
 * which returns both in the order that they are found (at the expense, that you
 * now must use typechecks to find out what you got).
 *
 * @category Sidebar
 */
let WelcomeContentSection = class WelcomeContentSection extends BasePage {
    /**
     * @param panel  The panel containing the welcome content.
     * @param parent  The webelement in which the welcome content is embedded.
     */
    constructor(locators, panel, parent) {
        super(locators, panel, parent.elem);
        /**
         * @private
         */
        this.locatorKey = 'WelcomeContent';
    }
    /**
     * Combination of [[getButtons]] and [[getTextSections]]: returns all entries in the welcome
     * view in the order that they appear.
     */
    async getContents() {
        const elements = await this.buttonOrText$$;
        return Promise.all(elements.map(async (e) => {
            const tagName = await e.getTagName();
            if (tagName === 'p') {
                return e.getText();
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return new WelcomeContentButton(this.locatorMap, e, this);
        }));
    }
    /** Finds all buttons in the welcome content */
    getButtons() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return this.button$$.map((elem) => new WelcomeContentButton(this.locatorMap, elem, this));
    }
    /**
     * Finds all text entries in the welcome content and returns each line as an
     * element in an array.
     */
    getTextSections() {
        return this.text$$.map((elem) => elem.getText());
    }
};
WelcomeContentSection = __decorate([
    PageDecorator(WelcomeContentLocators)
], WelcomeContentSection);
export { WelcomeContentSection };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2VsY29tZUNvbnRlbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGFnZW9iamVjdHMvc2lkZWJhci9XZWxjb21lQ29udGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFHQSxPQUFPLEVBQ0gsUUFBUSxFQUFFLGFBQWEsRUFDMUIsTUFBTSxhQUFhLENBQUE7QUFDcEIsT0FBTyxFQUFFLGNBQWMsSUFBSSxzQkFBc0IsRUFBRSxNQUFNLDBCQUEwQixDQUFBO0FBR25GOzs7Ozs7R0FNRztBQUVJLElBQU0sb0JBQW9CLEdBQTFCLE1BQU0sb0JBQXFCLFNBQVEsUUFBdUM7SUFNN0U7OztPQUdHO0lBQ0gsWUFDSSxRQUEwQixFQUMxQixLQUFtRCxFQUM1QyxjQUFxQztRQUU1QyxLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFBO1FBRmYsbUJBQWMsR0FBZCxjQUFjLENBQXVCO1FBWmhEOztXQUVHO1FBQ0ksZUFBVSxHQUFHLGdCQUF5QixDQUFBO0lBWTdDLENBQUM7SUFFRCxnREFBZ0Q7SUFDekMsUUFBUTtRQUNYLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUM5QixDQUFDO0NBQ0osQ0FBQTtBQXRCWSxvQkFBb0I7SUFEaEMsYUFBYSxDQUFDLHNCQUFzQixDQUFDO0dBQ3pCLG9CQUFvQixDQXNCaEM7U0F0Qlksb0JBQW9CO0FBeUJqQzs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUksSUFBTSxxQkFBcUIsR0FBM0IsTUFBTSxxQkFBc0IsU0FBUSxRQUF1QztJQU05RTs7O09BR0c7SUFDSCxZQUNJLFFBQTBCLEVBQzFCLEtBQW1ELEVBQ25ELE1BQW1CO1FBRW5CLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQWR2Qzs7V0FFRztRQUNJLGVBQVUsR0FBRyxnQkFBeUIsQ0FBQTtJQVk3QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksS0FBSyxDQUFDLFdBQVc7UUFDcEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFBO1FBQzFDLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQTtZQUNwQyxJQUFJLE9BQU8sS0FBSyxHQUFHLEVBQUU7Z0JBQ2pCLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFBO2FBQ3JCO1lBRUQsaUVBQWlFO1lBQ2pFLE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQTtRQUNwRSxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQ1AsQ0FBQztJQUVELCtDQUErQztJQUN4QyxVQUFVO1FBQ2IsaUVBQWlFO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFXLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQTtJQUNwRyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksZUFBZTtRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQTtJQUNwRCxDQUFDO0NBQ0osQ0FBQTtBQWhEWSxxQkFBcUI7SUFEakMsYUFBYSxDQUFDLHNCQUFzQixDQUFDO0dBQ3pCLHFCQUFxQixDQWdEakM7U0FoRFkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhaW5hYmxlUHJvbWlzZUVsZW1lbnQgfSBmcm9tICd3ZWJkcml2ZXJpbydcblxuaW1wb3J0IHsgVmlld1NlY3Rpb24gfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7XG4gICAgQmFzZVBhZ2UsIFBhZ2VEZWNvcmF0b3IsIElQYWdlRGVjb3JhdG9yLCBWU0NvZGVMb2NhdG9yTWFwXG59IGZyb20gJy4uL3V0aWxzLmpzJ1xuaW1wb3J0IHsgV2VsY29tZUNvbnRlbnQgYXMgV2VsY29tZUNvbnRlbnRMb2NhdG9ycyB9IGZyb20gJy4uLy4uL2xvY2F0b3JzLzEuNzMuMC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBXZWxjb21lQ29udGVudEJ1dHRvbiBleHRlbmRzIElQYWdlRGVjb3JhdG9yPHR5cGVvZiBXZWxjb21lQ29udGVudExvY2F0b3JzPiB7fVxuLyoqXG4gKiBBIGJ1dHRvbiB0aGF0IGFwcGVhcnMgaW4gdGhlIHdlbGNvbWUgY29udGVudCBhbmQgY2FuIGJlIGNsaWNrZWQgdG8gZXhlY3V0ZSBhIGNvbW1hbmQuXG4gKlxuICogVG8gZXhlY3V0ZSB0aGUgY29tbWFuZCBib3VuZCB0byB0aGlzIGJ1dHRvbiBzaW1wbHkgcnVuOiBgYXdhaXQgYnV0dG9uLmNsaWNrKCk7YC5cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihXZWxjb21lQ29udGVudExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFdlbGNvbWVDb250ZW50QnV0dG9uIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFdlbGNvbWVDb250ZW50TG9jYXRvcnM+IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2NhdG9yS2V5ID0gJ1dlbGNvbWVDb250ZW50JyBhcyBjb25zdFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhbmVsICBUaGUgcGFuZWwgY29udGFpbmluZyB0aGUgYnV0dG9uIGluIHRoZSB3ZWxjb21lIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0gd2VsY29tZVNlY3Rpb24gIFRoZSBlbmNsb3Npbmcgd2VsY29tZSBzZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBsb2NhdG9yczogVlNDb2RlTG9jYXRvck1hcCxcbiAgICAgICAgcGFuZWw6IENoYWluYWJsZVByb21pc2VFbGVtZW50PFdlYmRyaXZlcklPLkVsZW1lbnQ+LFxuICAgICAgICBwdWJsaWMgd2VsY29tZVNlY3Rpb246IFdlbGNvbWVDb250ZW50U2VjdGlvblxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgcGFuZWwpXG4gICAgfVxuXG4gICAgLyoqIFJldHVybiB0aGUgdGl0bGUgZGlzcGxheWVkIG9uIHRoaXMgYnV0dG9uICovXG4gICAgcHVibGljIGdldFRpdGxlICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLmdldFRleHQoKVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWxjb21lQ29udGVudFNlY3Rpb24gZXh0ZW5kcyBJUGFnZURlY29yYXRvcjx0eXBlb2YgV2VsY29tZUNvbnRlbnRMb2NhdG9ycz4ge31cbi8qKlxuICogQSBzZWN0aW9uIGluIGFuIGVtcHR5IGN1c3RvbSB2aWV3LCBzZWU6XG4gKiBodHRwczovL2NvZGUudmlzdWFsc3R1ZGlvLmNvbS9hcGkvZXh0ZW5zaW9uLWd1aWRlcy90cmVlLXZpZXcjd2VsY29tZS1jb250ZW50XG4gKlxuICogVGhlIHdlbGNvbWUgc2VjdGlvbiBjb250YWlucyB0d28gdHlwZXMgb2YgZWxlbWVudHM6IHRleHQgZW50cmllcyBhbmQgYnV0dG9ucyB0aGF0IGNhbiBiZSBib3VuZCB0byBjb21tYW5kcy5cbiAqIFRoZSB0ZXh0IHNlY3Rpb25zIGNhbiBiZSBhY2Nlc3NlZCB2aWEgW1tnZXRUZXh0U2VjdGlvbnNdXSwgdGhlIGJ1dHRvbnMgb24gdGhlXG4gKiBvdGhlciBoYW5kIHZpYSBbW2dldEJ1dHRvbnNdXS5cbiAqIFRoaXMgaG93ZXZlciBsb29zZXMgdGhlIGluZm9ybWF0aW9uIG9mIHRoZSBvcmRlciBvZiB0aGUgYnV0dG9ucyBhbmQgbGluZXNcbiAqIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLiBUaGlzIGNhbiBiZSByZW1lZGllZCBieSB1c2luZyBbW2dldENvbnRlbnRzXV0sXG4gKiB3aGljaCByZXR1cm5zIGJvdGggaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgZm91bmQgKGF0IHRoZSBleHBlbnNlLCB0aGF0IHlvdVxuICogbm93IG11c3QgdXNlIHR5cGVjaGVja3MgdG8gZmluZCBvdXQgd2hhdCB5b3UgZ290KS5cbiAqXG4gKiBAY2F0ZWdvcnkgU2lkZWJhclxuICovXG5AUGFnZURlY29yYXRvcihXZWxjb21lQ29udGVudExvY2F0b3JzKVxuZXhwb3J0IGNsYXNzIFdlbGNvbWVDb250ZW50U2VjdGlvbiBleHRlbmRzIEJhc2VQYWdlPHR5cGVvZiBXZWxjb21lQ29udGVudExvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdXZWxjb21lQ29udGVudCcgYXMgY29uc3RcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYW5lbCAgVGhlIHBhbmVsIGNvbnRhaW5pbmcgdGhlIHdlbGNvbWUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gcGFyZW50ICBUaGUgd2ViZWxlbWVudCBpbiB3aGljaCB0aGUgd2VsY29tZSBjb250ZW50IGlzIGVtYmVkZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgbG9jYXRvcnM6IFZTQ29kZUxvY2F0b3JNYXAsXG4gICAgICAgIHBhbmVsOiBDaGFpbmFibGVQcm9taXNlRWxlbWVudDxXZWJkcml2ZXJJTy5FbGVtZW50PixcbiAgICAgICAgcGFyZW50OiBWaWV3U2VjdGlvblxuICAgICkge1xuICAgICAgICBzdXBlcihsb2NhdG9ycywgcGFuZWwsIHBhcmVudC5lbGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmF0aW9uIG9mIFtbZ2V0QnV0dG9uc11dIGFuZCBbW2dldFRleHRTZWN0aW9uc11dOiByZXR1cm5zIGFsbCBlbnRyaWVzIGluIHRoZSB3ZWxjb21lXG4gICAgICogdmlldyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFwcGVhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0Q29udGVudHMgKCk6IFByb21pc2U8KFdlbGNvbWVDb250ZW50QnV0dG9uIHwgc3RyaW5nKVtdPiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXdhaXQgdGhpcy5idXR0b25PclRleHQkJFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMubWFwKGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gYXdhaXQgZS5nZXRUYWdOYW1lKClcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRUZXh0KClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2VsY29tZUNvbnRlbnRCdXR0b24odGhpcy5sb2NhdG9yTWFwLCBlIGFzIGFueSwgdGhpcylcbiAgICAgICAgfSkpXG4gICAgfVxuXG4gICAgLyoqIEZpbmRzIGFsbCBidXR0b25zIGluIHRoZSB3ZWxjb21lIGNvbnRlbnQgKi9cbiAgICBwdWJsaWMgZ2V0QnV0dG9ucyAoKTogUHJvbWlzZTxXZWxjb21lQ29udGVudEJ1dHRvbltdPiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbiQkLm1hcCgoZWxlbSkgPT4gbmV3IFdlbGNvbWVDb250ZW50QnV0dG9uKHRoaXMubG9jYXRvck1hcCwgZWxlbSBhcyBhbnksIHRoaXMpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCB0ZXh0IGVudHJpZXMgaW4gdGhlIHdlbGNvbWUgY29udGVudCBhbmQgcmV0dXJucyBlYWNoIGxpbmUgYXMgYW5cbiAgICAgKiBlbGVtZW50IGluIGFuIGFycmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUZXh0U2VjdGlvbnMgKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCQkLm1hcCgoZWxlbSkgPT4gZWxlbS5nZXRUZXh0KCkpXG4gICAgfVxufVxuIl19