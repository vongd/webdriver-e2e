var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PageDecorator, BasePage } from '../utils.js';
import { StatusBar as StatusBarLocators } from '../../locators/1.73.0.js';
import { NotificationsCenter } from '../index.js';
/**
 * Page object for the status bar at the bottom
 *
 * @category Statusbar
 */
let StatusBar = class StatusBar extends BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'StatusBar';
    }
    /**
     * Retrieve all status bar items currently displayed
     * @returns Promise resolving to an array of WebElement
     */
    async getItems() {
        const elems = await this.item$$;
        const items = [];
        for (const elem of elems) {
            items.push(await elem.getAttribute(this.locators.itemTitle));
        }
        return items.map((i) => i.trim()).filter(Boolean);
    }
    /**
     * Find status bar item by title/visible label
     * @param title title of the item
     * @returns Promise resolving to a WebElement if item is found, to undefined otherwise
     */
    async getItem(title) {
        const items = await this.item$$;
        for (const item of items) {
            if (await item.getAttribute(this.locators.itemTitle) === title) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Open the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    async openNotificationsCenter() {
        await this.toggleNotificationsCentre(true);
        return new NotificationsCenter(this.locatorMap);
    }
    /**
     * Close the notifications center
     * @returns Promise resolving when the notifications center is closed
     */
    async closeNotificationsCenter() {
        await this.toggleNotificationsCentre(false);
    }
    /**
     * Open the language selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the language selection is opened
     */
    async openLanguageSelection() {
        await this.language$.click();
    }
    /**
     * Get the current language label text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current language
     */
    async getCurrentLanguage() {
        return this.getPartText(this.locators.language);
    }
    /**
     * Open the quick pick for line endings selection
     * Only works with an open editor
     * @returns Promise resolving when the line ending selection is opened
     */
    async openLineEndingSelection() {
        await this.lines$.click();
    }
    /**
     * Get the currently selected line ending as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current line ending
     */
    async getCurrentLineEnding() {
        return this.getPartText(this.locators.lines);
    }
    /**
     * Open the encoding selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the encoding selection is opened
     */
    async openEncodingSelection() {
        await this.encoding$.click();
    }
    /**
     * Get the name of the current encoding as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current encoding
     */
    async getCurrentEncoding() {
        return this.getPartText(this.locators.encoding);
    }
    /**
     * Open the indentation selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the indentation selection is opened
     */
    async openIndentationSelection() {
        await this.indent$.click();
    }
    /**
     * Get the current indentation option label as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current indentation
     */
    async getCurrentIndentation() {
        return this.getPartText(this.locators.indent);
    }
    /**
     * Open the line selection input box
     * Only works with an open editor
     * @returns Promise resolving when the line selection is opened
     */
    async openLineSelection() {
        await this.selection$.click();
    }
    /**
     * Get the current editor coordinates as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current position in the editor
     */
    async getCurrentPosition() {
        return this.getPartText(this.locators.selection);
    }
    /**
     * Open/Close notification centre
     * @param open true to open, false to close
     */
    async toggleNotificationsCentre(open) {
        let visible = false;
        try {
            const klass = await browser
                .$(this.locatorMap.Workbench.elem)
                .$(this.locators.notifications)
                .getAttribute('class');
            visible = klass.indexOf('visible') > -1;
        }
        catch (err) {
            // element doesn't exist until the button is first clicked
        }
        if (visible !== open) {
            await this.bell$.click();
        }
    }
    async getPartText(locator) {
        return this.elem.$(locator).$('a').getText();
    }
};
StatusBar = __decorate([
    PageDecorator(StatusBarLocators)
], StatusBar);
export { StatusBar };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdHVzQmFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3BhZ2VvYmplY3RzL3N0YXR1c0Jhci9TdGF0dXNCYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUFFLGFBQWEsRUFBa0IsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBQ3JFLE9BQU8sRUFBRSxTQUFTLElBQUksaUJBQWlCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxhQUFhLENBQUE7QUFHakQ7Ozs7R0FJRztBQUVJLElBQU0sU0FBUyxHQUFmLE1BQU0sU0FBVSxTQUFRLFFBQWtDO0lBQTFEOztRQUNIOztXQUVHO1FBQ0ksZUFBVSxHQUFHLFdBQW9CLENBQUE7SUFnSzVDLENBQUM7SUE5Skc7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFFBQVE7UUFDVixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUE7UUFDL0IsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFBO1FBQzFCLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3RCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtTQUMvRDtRQUNELE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3JELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FBRSxLQUFhO1FBQ3hCLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQTtRQUMvQixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtZQUN0QixJQUFJ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LENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFBO1NBQzNCO0lBQ0wsQ0FBQztJQUVPLEtBQUssQ0FBQyxXQUFXLENBQUUsT0FBZTtRQUN0QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUNoRCxDQUFDO0NBQ0osQ0FBQTtBQXBLWSxTQUFTO0lBRHJCLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztHQUNwQixTQUFTLENBb0tyQjtTQXBLWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZURlY29yYXRvciwgSVBhZ2VEZWNvcmF0b3IsIEJhc2VQYWdlIH0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBTdGF0dXNCYXIgYXMgU3RhdHVzQmFyTG9jYXRvcnMgfSBmcm9tICcuLi8uLi9sb2NhdG9ycy8xLjczLjAuanMnXG5pbXBvcnQgeyBOb3RpZmljYXRpb25zQ2VudGVyIH0gZnJvbSAnLi4vaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdHVzQmFyIGV4dGVuZHMgSVBhZ2VEZWNvcmF0b3I8dHlwZW9mIFN0YXR1c0JhckxvY2F0b3JzPiB7fVxuLyoqXG4gKiBQYWdlIG9iamVjdCBmb3IgdGhlIHN0YXR1cyBiYXIgYXQgdGhlIGJvdHRvbVxuICpcbiAqIEBjYXRlZ29yeSBTdGF0dXNiYXJcbiAqL1xuQFBhZ2VEZWNvcmF0b3IoU3RhdHVzQmFyTG9jYXRvcnMpXG5leHBvcnQgY2xhc3MgU3RhdHVzQmFyIGV4dGVuZHMgQmFzZVBhZ2U8dHlwZW9mIFN0YXR1c0JhckxvY2F0b3JzPiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9jYXRvcktleSA9ICdTdGF0dXNCYXInIGFzIGNvbnN0XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgc3RhdHVzIGJhciBpdGVtcyBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgV2ViRWxlbWVudFxuICAgICAqL1xuICAgIGFzeW5jIGdldEl0ZW1zICgpIHtcbiAgICAgICAgY29uc3QgZWxlbXMgPSBhd2FpdCB0aGlzLml0ZW0kJFxuICAgICAgICBjb25zdCBpdGVtczogc3RyaW5nW10gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZWxlbXMpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYXdhaXQgZWxlbS5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhdG9ycy5pdGVtVGl0bGUpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGkpID0+IGkudHJpbSgpKS5maWx0ZXIoQm9vbGVhbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHN0YXR1cyBiYXIgaXRlbSBieSB0aXRsZS92aXNpYmxlIGxhYmVsXG4gICAgICogQHBhcmFtIHRpdGxlIHRpdGxlIG9mIHRoZSBpdGVtXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBXZWJFbGVtZW50IGlmIGl0ZW0gaXMgZm91bmQsIHRvIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJdGVtICh0aXRsZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5pdGVtJCRcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgaXRlbS5nZXRBdHRyaWJ1dGUodGhpcy5sb2NhdG9ycy5pdGVtVGl0bGUpID09PSB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIG5vdGlmaWNhdGlvbnMgY2VudGVyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gTm90aWZpY2F0aW9uc0NlbnRlciBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTm90aWZpY2F0aW9uc0NlbnRlciAoKTogUHJvbWlzZTxOb3RpZmljYXRpb25zQ2VudGVyPiB7XG4gICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlTm90aWZpY2F0aW9uc0NlbnRyZSh0cnVlKVxuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbnNDZW50ZXIodGhpcy5sb2NhdG9yTWFwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBub3RpZmljYXRpb25zIGNlbnRlclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIG5vdGlmaWNhdGlvbnMgY2VudGVyIGlzIGNsb3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlTm90aWZpY2F0aW9uc0NlbnRlciAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlTm90aWZpY2F0aW9uc0NlbnRyZShmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBsYW5ndWFnZSBzZWxlY3Rpb24gcXVpY2sgcGlja1xuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGxhbmd1YWdlIHNlbGVjdGlvbiBpcyBvcGVuZWRcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuTGFuZ3VhZ2VTZWxlY3Rpb24gKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLmxhbmd1YWdlJC5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGxhbmd1YWdlIGxhYmVsIHRleHRcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBsYW5ndWFnZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRMYW5ndWFnZSAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFydFRleHQodGhpcy5sb2NhdG9ycy5sYW5ndWFnZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBxdWljayBwaWNrIGZvciBsaW5lIGVuZGluZ3Mgc2VsZWN0aW9uXG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgbGluZSBlbmRpbmcgc2VsZWN0aW9uIGlzIG9wZW5lZFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5MaW5lRW5kaW5nU2VsZWN0aW9uICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5saW5lcyQuY2xpY2soKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGxpbmUgZW5kaW5nIGFzIHRleHRcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBsaW5lIGVuZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRMaW5lRW5kaW5nICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJ0VGV4dCh0aGlzLmxvY2F0b3JzLmxpbmVzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGVuY29kaW5nIHNlbGVjdGlvbiBxdWljayBwaWNrXG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgZW5jb2Rpbmcgc2VsZWN0aW9uIGlzIG9wZW5lZFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5FbmNvZGluZ1NlbGVjdGlvbiAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5jb2RpbmckLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgZW5jb2RpbmcgYXMgdGV4dFxuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjdXJyZW50IGVuY29kaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudEVuY29kaW5nICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJ0VGV4dCh0aGlzLmxvY2F0b3JzLmVuY29kaW5nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGluZGVudGF0aW9uIHNlbGVjdGlvbiBxdWljayBwaWNrXG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaW5kZW50YXRpb24gc2VsZWN0aW9uIGlzIG9wZW5lZFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5JbmRlbnRhdGlvblNlbGVjdGlvbiAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5kZW50JC5jbGljaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGluZGVudGF0aW9uIG9wdGlvbiBsYWJlbCBhcyB0ZXh0XG4gICAgICogT25seSB3b3JrcyB3aXRoIGFuIG9wZW4gZWRpdG9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgaW5kZW50YXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50SW5kZW50YXRpb24gKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcnRUZXh0KHRoaXMubG9jYXRvcnMuaW5kZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGxpbmUgc2VsZWN0aW9uIGlucHV0IGJveFxuICAgICAqIE9ubHkgd29ya3Mgd2l0aCBhbiBvcGVuIGVkaXRvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGxpbmUgc2VsZWN0aW9uIGlzIG9wZW5lZFxuICAgICAqL1xuICAgIGFzeW5jIG9wZW5MaW5lU2VsZWN0aW9uICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZWxlY3Rpb24kLmNsaWNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGNvb3JkaW5hdGVzIGFzIHRleHRcbiAgICAgKiBPbmx5IHdvcmtzIHdpdGggYW4gb3BlbiBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudFBvc2l0aW9uICgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJ0VGV4dCh0aGlzLmxvY2F0b3JzLnNlbGVjdGlvbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuL0Nsb3NlIG5vdGlmaWNhdGlvbiBjZW50cmVcbiAgICAgKiBAcGFyYW0gb3BlbiB0cnVlIHRvIG9wZW4sIGZhbHNlIHRvIGNsb3NlXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyB0b2dnbGVOb3RpZmljYXRpb25zQ2VudHJlIChvcGVuOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGxldCB2aXNpYmxlID0gZmFsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGtsYXNzID0gYXdhaXQgYnJvd3NlclxuICAgICAgICAgICAgICAgIC4kKHRoaXMubG9jYXRvck1hcC5Xb3JrYmVuY2guZWxlbSBhcyBzdHJpbmcpXG4gICAgICAgICAgICAgICAgLiQodGhpcy5sb2NhdG9ycy5ub3RpZmljYXRpb25zKVxuICAgICAgICAgICAgICAgIC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcbiAgICAgICAgICAgIHZpc2libGUgPSBrbGFzcy5pbmRleE9mKCd2aXNpYmxlJykgPiAtMVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgZG9lc24ndCBleGlzdCB1bnRpbCB0aGUgYnV0dG9uIGlzIGZpcnN0IGNsaWNrZWRcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSAhPT0gb3Blbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5iZWxsJC5jbGljaygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldFBhcnRUZXh0IChsb2NhdG9yOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLiQobG9jYXRvcikuJCgnYScpLmdldFRleHQoKVxuICAgIH1cbn1cbiJdfQ==